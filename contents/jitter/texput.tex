% Emacs, this is -*-latex-*-

\title{Hidding the Jitter}

\maketitle
\tableofcontents

\section{Latencies}
\href{https://en.wikipedia.org/wiki/Latency_(engineering)#Communication_latency}{Communication
  latency} (also called
\href{https://en.wikipedia.org/wiki/Network_delay}{network delay} and
\href{https://en.wikipedia.org/wiki/End-to-end_delay}{end-to-end
  delay}) is the time it takes for a chunk of data (encapsulated
in an \href{https://en.wikipedia.org/wiki/Internet_Protocol}{IP}
\href{https://en.wikipedia.org/wiki/Network_packet}{packet}) to travel
from one end-point of the network to another. This time is relevant
for an intercom(municator) because the total latency $t_u$ that users
experiment can be approximated by
\begin{equation}
  t_u = t_p + t_i,
  \label{eq:user_latency}
\end{equation}
where $t_p$ is the \emph{propagation time} (or propagation latency) of
the \href{https://en.wikipedia.org/wiki/Telecommunications_link}{link}
and $t_i$ is the \emph{latency} generated by the intercom.

Due to the current design of the Internet~\cite{Tanenbaum,Stallings}
(where the available
\href{https://en.wikipedia.org/wiki/Bandwidth_(computing)}{bandwidth}
is shared on demand by the network users) $t_p$ is variable
and cannot be controlled without using
\href{https://en.wikipedia.org/wiki/Quality_of_service}{Quality of
  Service (QoS)}\footnote{Something that is not available to normal
network users.}~\cite{dordal2020intro}. In contrast, $t_i$ is constant
for a given intercom configuration/implementation.

\section{Using a buffer to hidden the jitter}

We can consider that the
\href{https://en.wikipedia.org/wiki/Quality_of_experience}{Quality of
  Experience (QoE)} provided by any intercom is inversely proportional
to the
\href{https://en.wikipedia.org/wiki/Packet_delay_variation}{jitter of
  the network}, i.e., to the variation of the latency (see
Fig.~\ref{fig:timelines}-a). One solution (see
Fig.~\ref{fig:timelines}-b) is the use of a
\href{https://en.wikipedia.org/wiki/Random_access}{random access}
\href{https://en.wikipedia.org/wiki/Data_buffer}{buffer} at the
receiver side, where the chunks are stored for a time large enough to
hide the jitter~\cite{Kurose-Ross}.

\begin{figure}
  \begin{center}
    \myfig{graphics/timelines}{10cm}{1000}
  \end{center}
  \caption{Timelines of the interaction between two InterCom
    instances. On the left case, the playback is defective because some
    chunks are lost. On the right, the audio rendering is correct
    because the playback has been delayed 2 chunk times (enough for
    this example).}
  \label{fig:timelines}
\end{figure}

\href{https://en.wikipedia.org/wiki/Jitter#Jitter_buffers}{\emph{Dejitterizing}
  buffers}\footnote{Usually implemented with random access buffers.}
are typically implemented as a circular buffer structure (see
Fig.~\ref{fig:circular_buffer}). In an ideal situation (as depicted in
the figure), the number of pending-to-be-played chunks available in
the buffer is half of the number of slots in the buffer, and the
chunks have arrived on time. In this example
(Fig.~\ref{fig:circular_buffer}), the receiver (where the chunks are
buffered) waits for receiving 3 chunks before starting to play the
chunk number 0.\footnote{Implementation tip: in a system where for
  each recorded chunk a chunk must be also played, a delay in the
  playback can be generated by sending zero-chunks to the DAC and
  then, after the delay, start sending the received chunk of audio, in
  the right order.} Notice that the number of slots in the buffer,
$2N$, must double the number of chunks buffered during the buffering
time proportional to $N$, in order to hide a jitter of $N$
chunks-time. Notice also that this technique also introduces a
$N\times$ chunk-time delay in the playback.

\begin{figure}
  \begin{tabular}{ccc}
    \vbox{\myfig{graphics/circular_buffer1}{2cm}{200}} & \vbox{\myfig{graphics/circular_buffer2}{2cm}{200}} & \vbox{\myfig{graphics/circular_buffer3}{2cm}{200}} \\
    (a) & (b) & (c)
  \end{tabular}
  \caption{A circular buffer with 6 slots (space for 6 chunks). Half
    of the buffer is occupied (slots in gray) because the buffering
    time is 3 chunk times and 3 chunks (with chunk number 0, 1 and 2
    in the beginning, subfigure (a)) have been received. The first
    chunk to be played is chunk 0 (subfigure (b)). Then, a new chunk
    (chunk number 3) is received and buffered (subfigure (c)).}
  \label{fig:circular_buffer}
\end{figure}
For this new improved InterCom, users must provide a new parameter
called ``\emph{buffering time}''. This value (typically expressed in
milliseconds) should be large enough to hide the network jitter but
small enough to keep the end-to-end (user) latency below some limit.

The following guidelines have been used to implement the
\emph{buffered} version of InterCom:

\begin{enumerate}
\item The class \texttt{Minimal} has been
  \href{https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)}{inherited}
  (extended) to implement a new class \texttt{Buffering}.
\item In the payload of each UDP packet, a chunk number (a 16-bits
  counter) has been included in order to provide to the receiver the
  information to determine where to store the corresponding chunk in
  the circular buffer.
\item It has been taken into consideration that the critical part of
  InterCom (the method \verb|record_send_and_play()|) is a method that
  runs as an
  \href{https://en.wikipedia.org/wiki/Interrupt_handler}{interrup
    handler} that is called each time a new chunk is available in the
  \href{https://en.wikipedia.org/wiki/Analog-to-digital_converter}{ADC}. More
  precisely:
  \begin{enumerate}
  \item To minimize the latency, the recorded chunks are sent
    to the interlocutor as soon as possible.
  \item The playback of the chunks extracted from the buffer is
    \href{https://en.wikipedia.org/wiki/Gapless_playback}{\emph{gapless}}
    (without the occurrence of silences) as long as the chunks have
    been received on time.
  \item The lost\footnote{Those chunks that have not been
  received on time or never have been received.} chunks are replaced
    by zero-chunks in the playback.
  \end{enumerate}
\item A method \verb|receive_and_buffer()| runs now in a different
  execution
  \href{https://en.wikipedia.org/wiki/Thread_(computing)}{thread},
  decoupled from the \verb|record_send_and_play()| method. But notice
  that this can be achieved without using the
  \href{https://docs.python.org/3/library/threading.html}{threading}
  or
  \href{https://docs.python.org/3/library/multiprocessing.html}{multiprocessing}
  packages because the interruption handler (the so called
  \emph{callback}() function in
  \href{https://python-sounddevice.readthedocs.io/en/0.3.14/api.html}{sounddevice})
  already runs in parallel with the main thread.
\end{enumerate}

This is an overview of the implementation:

\begin{lstlisting}[language=Python]
  # Interruption handler
  def record_send_and_play():
    chunk = record()  # (1)
    packed_chunk = pack(chunk)  # (2)
    send(packed_chunk)  # (3)
    chunk = unbuffer_next_chunk()  # (4)
    play(chunk)  # (5)

  # Main (not a new) thread
  def receive_and_buffer():
    packed_chunk = receive()  # (1)
    chunk_number, chunk = unpack(packed_chunk)  # (2)
    buffer(chunk_number, chunk)  # (3)
\end{lstlisting}

Notice that Step (4) of the method \verb|record_send_and_play()|
extracts from the buffer an unpacked\footnote{Chunks will be
compressed in a posterior milestone, and uncompressing is performed in
this step.} chunk. The chunks are buffered in Step (3) of the
method \verb|receive_and_buffer()|. Note also that Step (1) of
\verb|receive_and_buffer()| is a blocking method that should return with
every new received chunk.

%\begin{pseudocode}{Buffering\_InterCom}{~}
%  \PROCEDURE{record\_send\_and\_play}{~}
%  \BEGIN
%    \text{chunk} \GETS \text{record}()\\
%    \text{packed\_chunk} \GETS \text{pack}(\text{chunk})\\
%    \text{send}(\text{packed\_chunk})\\
%    \text{chunk} \GETS \text{unbuffer\_next\_chunk}()\\
%    \text{play}(\text{chunk})
%  \END
%  \ENDPROCEDURE
%  \PROCEDURE{receive\_and\_buffer}{~}
%  \BEGIN
%    \text{packed\_chunk} \GETS \text{receive}()\\
%    \text{chunk\_number}, \text{chunk} \GETS \text{unpack}(\text{packe%d\_chunk})\\
%    \text{buffer}(\text{chunk\_number}, \text{chunk})
%  \END
%  \ENDPROCEDURE
%\end{pseudocode}

\section{Deliverables}
\label{sec:homework}

\begin{enumerate}
% \item \textbf{Show the performance of Minimal in congested links}:
%   Determine the quality of the sound when \texttt{minimal.py} is used
%   in a congested tranmission environment. You can quantify the
%   \href{https://en.wikipedia.org/wiki/Quality_of_experience}{QoE}
%   using the following classification:
% \begin{itemize}
% \item \textbf{Perfect}: no loss or delay can be perceived.
% \item \textbf{Good}: if you detect some minimal distortion in the
%   rendering of the sound.
% \item \textbf{Acceptable}: when the effects of the latency are
%   noticeable, but you can communicate with your interlocutor.
% \item \textbf{Bad}: you are able to recognize only small parts of the
%   received audio.
% \item \textbf{No way}: when most of the time only silence is heard.
% \end{itemize}

\item \textbf{Find your minimum buffering time}:
Determine, experimentally:
\begin{enumerate}
\item The minimum artificial latency that you must configure in your
  InterCom instance to communicate with your groupmate without lossing
  chunks, when he/she is in a different\footnote{Different to the
    network in which you are using InterCom.} local
  network. \href{https://vicente-gonzalez-ruiz.github.io/about_ping/}{Ping}
  can help to estimate the latency.
\item Repeat the previous experiment using only localhost (transmiting
  the chunk between the loopback network adapter), but adding some
  jitter with the tool
  \href{https://vicente-gonzalez-ruiz.github.io/about_tc/}{\texttt{tc}}. If
  \texttt{tc} is not avaiable in your OS, you can use any other
  similar tool, or use the Linux system at the laboratory.
\end{enumerate}

\subsection*{Example}
An example of a notebook related to this milestone can be found
\href{https://github.com/Tecnologias-multimedia/InterCom/blob/master/docs/Hidding_the_Network_Jitter__example.ipynb}{here}. Notice
that not all the content of the notebook could be requested in this
milestone.

\item To the report describing the previously requested
  experimentation, \textbf{add a section evaluating it} (with a ratio out of
  10), considering that each of the following rubrics has the same
  weight in the evaluation score:
\begin{enumerate}
\item Has this latency been determined in both cases (without
  simulating the latency or by simulating the latency (and its
  variation))?
\item Is the experiment perfectly described? In other words, can it be
  replicated with the information in the report?
\item Is there a coherent relationship between the jitter simulated
  with \texttt{tc} and the buffer time that must be used to avoid
  losing chunks?
\end{enumerate}
%Mark: \textbf{1 point}.

\end{enumerate}

\bibliography{networking,nat}
