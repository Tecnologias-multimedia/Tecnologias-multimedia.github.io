<!DOCTYPE html> 
<html lang='en-US' xml:lang='en-US'> 
<head> <title>Hidding the Jitter</title> 
<meta charset='utf-8' /> 
<meta content='TeX4ht (https://tug.org/tex4ht/)' name='generator' /> 
<meta content='width=device-width,initial-scale=1' name='viewport' /> 
<link href='index.css' rel='stylesheet' type='text/css' /> 
<meta content='index.tex' name='src' /> 
<script>window.MathJax = { tex: { tags: "ams", }, }; </script> 
 <script async='async' id='MathJax-script' src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js' type='text/javascript'></script>  
</head><body>
   <div class='maketitle'>
                                                                  

                                                                  
                                                                  

                                                                  

<h2 class='titleHead'>Hidding the Jitter</h2>
 <div class='author'><a href='https://vicente-gonzalez-ruiz.github.io/'><span class='ecrm-1200'>Vicente González Ruiz</span></a> <span class='ecrm-1200'>&amp; </span><a href='https://hpca.ual.es/~savins/'><span class='ecrm-1200'>Savins Puertas Martín</span></a> <span class='ecrm-1200'>&amp; </span><a href='https://www.marcoslupion.com/'><span class='ecrm-1200'>Marcos Lupión Lorente</span></a></div><br />
<div class='date'><span class='ecrm-1200'>September 24, 2024</span></div>
   </div>
   <h3 class='likesectionHead'><a id='x1-1000'></a>Contents</h3>
   <div class='tableofcontents'>
    <span class='sectionToc'>1 <a href='#x1-20001' id='QQ2-1-2'>Latencies</a></span>
<br />    <span class='sectionToc'>2 <a href='#x1-30002' id='QQ2-1-3'>Using a buffer to hidden the jitter</a></span>
<br />    <span class='sectionToc'>3 <a href='#x1-40003' id='QQ2-1-6'>Deliverables</a></span>
   </div>
<!-- l. 8 --><p class='noindent'>
</p>
   <h3 class='sectionHead'><span class='titlemark'>1   </span> <a id='x1-20001'></a>Latencies</h3>
<!-- l. 10 --><p class='noindent'><a href='https://en.wikipedia.org/wiki/Latency_(engineering)#Communication_latency'>Communication latency</a> (also called <a href='https://en.wikipedia.org/wiki/Network_delay'>network delay</a> and <a href='https://en.wikipedia.org/wiki/End-to-end_delay'>end-to-end delay</a>) is the time
it takes for that a chunk of data (encapsulated in an <a href='https://en.wikipedia.org/wiki/Internet_Protocol'>IP</a> <a href='https://en.wikipedia.org/wiki/Network_packet'>packet</a> in the case
of the Internet) to travel from one point of the network to another. This
time is relevant for an intercom(municator) because the total latency \(t_u\) that
users experiment can be approximated by \begin {equation}  t_u = t_p + t_i, \label {eq:user_latency}  \end {equation}<a id='x1-2001r1'></a> where \(t_p\) is the <span class='ecti-1000'>propagation time</span>
(or propagation latency) of the <a href='https://en.wikipedia.org/wiki/Telecommunications_link'>link</a> and \(t_i\) is the <span class='ecti-1000'>latency </span>generated by the
intercom.
</p><!-- l. 27 --><p class='indent'>   Due to the current design of the Internet <span class='cite'>[<a href='#XTanenbaum'>4</a>, <a href='#XStallings'>3</a>]</span> (where the available
<a href='https://en.wikipedia.org/wiki/Bandwidth_(computing)'>bandwidth</a> is shared on demand by the network users) \(t_p\) is variable
in time and cannot be controlled without using <a href='https://en.wikipedia.org/wiki/Quality_of_service'>Quality of Service
(QoS)</a><span class='footnote-mark'><a href='#fn1x0' id='fn1x0-bk'><sup class='textsuperscript'>1</sup></a></span><a id='x1-2002f1'></a> <span class='cite'>[<a href='#Xdordal2020intro'>1</a>]</span>.
In contrast, \(t_i\) is constant for a given intercom configuration/implementation.
                                                                  

                                                                  
</p><!-- l. 37 --><p class='noindent'>
</p>
   <h3 class='sectionHead'><span class='titlemark'>2   </span> <a id='x1-30002'></a>Using a buffer to hidden the jitter</h3>
<!-- l. 39 --><p class='noindent'>We can consider that the <a href='https://en.wikipedia.org/wiki/Quality_of_experience'>Quality of Experience (QoE)</a> provided by InterCom is
inversely proportional to the <a href='https://en.wikipedia.org/wiki/Packet_delay_variation'>jitter of the network</a> (see Fig. <a href='#x1-3001r1'>1<!-- tex4ht:ref: fig:timelines  --></a>-a). One solution (see
Fig. <a href='#x1-3001r1'>1<!-- tex4ht:ref: fig:timelines  --></a>-b) is the use of a <a href='https://en.wikipedia.org/wiki/Random_access'>random access</a> <a href='https://en.wikipedia.org/wiki/Data_buffer'>buffer</a> at the receiver side, where the chunks
are stored for a time large enough to hide the jitter <span class='cite'>[<a href='#XKurose-Ross'>2</a>]</span>.
</p>
   <figure class='figure'> 

                                                                  

                                                                  
                                                                  

                                                                  
<div class='center'>
<!-- l. 51 --><p class='noindent'>
</p><!-- l. 52 --><p class='noindent'><div style='text-align:center;'> <img src='graphics/timelines.svg' /> </div>  </p></div>
<a id='x1-3001r1'></a>
<figcaption class='caption'><span class='id'>Figure 1: </span><span class='content'>Timelines of two InterCom interactions. On the left, the playback is
defective because some chunks are lost. On the right, the audio rendering is
correct because the playback has been delayed 2 chunk times (enough for this
example).
</span></figcaption><!-- tex4ht:label?: x1-3001r1  -->
                                                                  

                                                                  
   </figure>
<!-- l. 62 --><p class='indent'>   <a href='https://en.wikipedia.org/wiki/Jitter#Jitter_buffers'><span class='ecti-1000'>Dejitterizing </span>buffers</a><span class='footnote-mark'><a href='#fn2x0' id='fn2x0-bk'><sup class='textsuperscript'>2</sup></a></span><a id='x1-3002f2'></a>
are typically implemented as a circular buffer structure (see Fig. <a href='#x1-3006r2'>2<!-- tex4ht:ref: fig:circular_buffer  --></a>). In an ideal
situation (as depicted in the figure), the number of pending-to-be-played chunks
available in the buffer is half of the number of slots in the buffer, and the chunks have
arrived on time. In this example (Fig. <a href='#x1-3006r2'>2<!-- tex4ht:ref: fig:circular_buffer  --></a>), the receiver (where the chunks
are buffered) waits for 3 chunks before starting playing the chunk number
0.<span class='footnote-mark'><a href='#fn3x0' id='fn3x0-bk'><sup class='textsuperscript'>3</sup></a></span><a id='x1-3004f3'></a>
Notice that the number of slots in the buffer, \(2N\), must double the number of chunks
buffered during the buffering time proportional to \(N\), in order to hide a jitter of \(N\)
chunks-time. Notice also that this technique also introduces a \(N\) chunk-time delay in
the playback.
</p>
   <figure class='figure'> 

                                                                  

                                                                  
                                                                  

                                                                  
<div class='tabular'> <table class='tabular' id='TBL-2'><colgroup id='TBL-2-1g'><col id='TBL-2-1' /><col id='TBL-2-2' /><col id='TBL-2-3' /></colgroup><tr id='TBL-2-1-' style='vertical-align:baseline;'><td class='td11' id='TBL-2-1-1' style='white-space:nowrap; text-align:center;'> <!-- l. 82 --><p class='noindent'><div style='text-align:center;'> <img src='graphics/circular_buffer1.svg' /> </div>                                                                    </p></td><td class='td11' id='TBL-2-1-2' style='white-space:nowrap; text-align:center;'> <!-- l. 82 --><p class='noindent'><div style='text-align:center;'> <img src='graphics/circular_buffer2.svg' /> </div>                                                                    </p></td><td class='td11' id='TBL-2-1-3' style='white-space:nowrap; text-align:center;'> <!-- l. 82 --><p class='noindent'><div style='text-align:center;'> <img src='graphics/circular_buffer3.svg' /> </div>                                                                    </p></td>
</tr><tr id='TBL-2-2-' style='vertical-align:baseline;'><td class='td11' id='TBL-2-2-1' style='white-space:nowrap; text-align:center;'>                                 (a)                                                    </td><td class='td11' id='TBL-2-2-2' style='white-space:nowrap; text-align:center;'>                                 (b)                                                    </td><td class='td11' id='TBL-2-2-3' style='white-space:nowrap; text-align:center;'>                                 (c)                                                    </td></tr></table></div>
<a id='x1-3006r2'></a>
<figcaption class='caption'><span class='id'>Figure 2: </span><span class='content'>A circular buffer with 6 slots (space for 6 chunks). Half of the buffer
is occupied (slots in gray) because the buffering time is 3 chunk times and 3
chunks (with chunk number 0, 1 and 2 in the beginning, subfigure (a)) have
been received. The first chunk to be played is chunk 0 (subfigure (b)). Then, a
new chunk (chunk number 3) is received and buffered (subfigure (c)).
</span></figcaption><!-- tex4ht:label?: x1-3006r2  -->
                                                                  

                                                                  
   </figure>
<!-- l. 94 --><p class='indent'>   For this new improved InterCom, users must provide a new parameter called
“<span class='ecti-1000'>buffering time</span>”. This value (typically expressed in milliseconds) should be large
enough to hide the network jitter but small enough to keep the end-to-end (user)
latency below some limit.
</p><!-- l. 99 --><p class='indent'>   The following guidelines have been used to implement the <span class='ecti-1000'>buffered </span>version of
InterCom:
     </p><ol class='enumerate1'>
<li class='enumerate' id='x1-3008x1'>The class Minimal has been <a href='https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)'>inherited</a> (extended) to implement a new class
     Buffering.
     </li>
<li class='enumerate' id='x1-3010x2'>In the payload of each UDP packet, a chunk number (a 16-bits counter)
     has been included in order to provide to the receiver the information which
     determine where to store the corresponding chunk in the circular buffer.
     </li>
<li class='enumerate' id='x1-3012x3'>
     <!-- l. 110 --><p class='noindent'>It has been taken into consideration that the critical part of InterCom (the
     method <span class='obeylines-h'><span class='verb'><span class='ectt-1000'>record_send_and_play()</span></span></span>) is a method that runs as an <a href='https://en.wikipedia.org/wiki/Interrupt_handler'>interrup
     handler</a> that is called each time a new chunk is available in the <a href='https://en.wikipedia.org/wiki/Analog-to-digital_converter'>ADC</a>. More
     precisely:
         </p><ol class='enumerate2'>
<li class='enumerate' id='x1-3014x1'>To  minimize  the  latency,  the  recorded  chunks  are  sent  to  the
         interlocutor as soon as possible.
         </li>
<li class='enumerate' id='x1-3016x2'>The  playback  of  the  chunks  extracted  from  the  buffer  is  <a href='https://en.wikipedia.org/wiki/Gapless_playback'><span class='ecti-1000'>gapless</span></a>
         (without the occurrence of silences) as long as the chunks have been
         received on time.
         </li>
<li class='enumerate' id='x1-3018x3'>The lost<span class='footnote-mark'><a href='#fn4x0' id='fn4x0-bk'><sup class='textsuperscript'>4</sup></a></span><a id='x1-3019f4'></a>
         chunks are replaced by zero-chunks in the playback.</li></ol>
                                                                  

                                                                  
     </li>
<li class='enumerate' id='x1-3022x4'>A method <span class='obeylines-h'><span class='verb'><span class='ectt-1000'>receive_and_buffer()</span></span></span> runs now in a different execution <a href='https://en.wikipedia.org/wiki/Thread_(computing)'>thread</a>,
     decoupled from the <span class='obeylines-h'><span class='verb'><span class='ectt-1000'>record_send_and_play()</span></span></span> method. But notice that this can
     be achieved without using the <a href='https://docs.python.org/3/library/threading.html'>threading</a> or <a href='https://docs.python.org/3/library/multiprocessing.html'>multiprocessing</a> packages because
     the interruption handler (the so called <span class='ecti-1000'>callback</span>() function in <a href='https://python-sounddevice.readthedocs.io/en/0.3.14/api.html'>sounddevice</a>)
     already runs in parallel with the main thread.</li></ol>
<!-- l. 142 --><p class='indent'>   This is an overview of the implementation:
</p>
   <!-- l. 144 -->
   <pre class='lstlisting' id='listing-1'><span class='label'><a id='x1-3023r1'></a></span><span class='ecit-1000'>  </span><span style='color:#000000'><span class='ecit-1000'>#</span></span><span style='color:#000000'> <span class='ecit-1000'>Interruption </span><span class='ecit-1000'>handler</span> 
</span><span class='label'><a id='x1-3024r2'></a></span><span class='ectt-1000'>  </span><span style='color:#000000'><span class='ectt-1000'>def</span></span><span style='color:#000000'> <span class='ectt-1000'>record_send_and_play():</span> 
</span><span class='label'><a id='x1-3025r3'></a></span><span class='ectt-1000'>   </span><span style='color:#000000'><span class='ectt-1000'>chunk</span></span><span style='color:#000000'> <span class='ectt-1000'>= </span><span class='ectt-1000'>record()</span> </span><span class='ecit-1000'> </span><span style='color:#000000'><span class='ecit-1000'>#</span></span><span style='color:#000000'> <span class='ecit-1000'>(1)</span> 
</span><span class='label'><a id='x1-3026r4'></a></span><span class='ectt-1000'>   </span><span style='color:#000000'><span class='ectt-1000'>packed_chunk</span></span><span style='color:#000000'> <span class='ectt-1000'>= </span><span class='ectt-1000'>pack(chunk)</span> </span><span class='ecit-1000'> </span><span style='color:#000000'><span class='ecit-1000'>#</span></span><span style='color:#000000'> <span class='ecit-1000'>(2)</span> 
</span><span class='label'><a id='x1-3027r5'></a></span><span class='ectt-1000'>   </span><span style='color:#000000'><span class='ectt-1000'>send</span></span><span style='color:#000000'><span class='ectt-1000'>(</span></span><span style='color:#000000'><span class='ectt-1000'>packed_chunk</span></span><span style='color:#000000'><span class='ectt-1000'>)</span></span><span style='color:#000000'> </span><span class='ecit-1000'> </span><span style='color:#000000'><span class='ecit-1000'>#</span></span><span style='color:#000000'> <span class='ecit-1000'>(3)</span> 
</span><span class='label'><a id='x1-3028r6'></a></span><span class='ectt-1000'>   </span><span style='color:#000000'><span class='ectt-1000'>chunk</span></span><span style='color:#000000'> <span class='ectt-1000'>= </span><span class='ectt-1000'>unbuffer_next_chunk()</span> </span><span class='ecit-1000'> </span><span style='color:#000000'><span class='ecit-1000'>#</span></span><span style='color:#000000'> <span class='ecit-1000'>(4)</span> 
</span><span class='label'><a id='x1-3029r7'></a></span><span class='ectt-1000'>   </span><span style='color:#000000'><span class='ectt-1000'>play</span></span><span style='color:#000000'><span class='ectt-1000'>(</span></span><span style='color:#000000'><span class='ectt-1000'>chunk</span></span><span style='color:#000000'><span class='ectt-1000'>)</span></span><span style='color:#000000'> </span><span class='ecit-1000'> </span><span style='color:#000000'><span class='ecit-1000'>#</span></span><span style='color:#000000'> <span class='ecit-1000'>(5)</span> 
</span><span class='label'><a id='x1-3030r8'></a></span> 
<span class='label'><a id='x1-3031r9'></a></span><span class='ecit-1000'>  </span><span style='color:#000000'><span class='ecit-1000'>#</span></span><span style='color:#000000'> <span class='ecit-1000'>Main </span><span class='ecit-1000'>(not </span><span class='ecit-1000'>a </span><span class='ecit-1000'>new) </span><span class='ecit-1000'>thread</span> 
</span><span class='label'><a id='x1-3032r10'></a></span><span class='ectt-1000'>  </span><span style='color:#000000'><span class='ectt-1000'>def</span></span><span style='color:#000000'> <span class='ectt-1000'>receive_and_buffer():</span> 
</span><span class='label'><a id='x1-3033r11'></a></span><span class='ectt-1000'>   </span><span style='color:#000000'><span class='ectt-1000'>packed_chunk</span></span><span style='color:#000000'> <span class='ectt-1000'>= </span><span class='ectt-1000'>receive()</span> </span><span class='ecit-1000'> </span><span style='color:#000000'><span class='ecit-1000'>#</span></span><span style='color:#000000'> <span class='ecit-1000'>(1)</span> 
</span><span class='label'><a id='x1-3034r12'></a></span><span class='ectt-1000'>   </span><span style='color:#000000'><span class='ectt-1000'>chunk_number</span></span><span style='color:#000000'><span class='ectt-1000'>,</span></span><span style='color:#000000'> <span class='ectt-1000'>chunk </span><span class='ectt-1000'>= </span><span class='ectt-1000'>unpack(packed_chunk)</span> </span><span class='ecit-1000'> </span><span style='color:#000000'><span class='ecit-1000'>#</span></span><span style='color:#000000'> <span class='ecit-1000'>(2)</span> 
</span><span class='label'><a id='x1-3035r13'></a></span><span class='ectt-1000'>   </span><span style='color:#000000'><span class='ectt-1000'>buffer</span></span><span style='color:#000000'><span class='ectt-1000'>(</span></span><span style='color:#000000'><span class='ectt-1000'>chunk_number</span></span><span style='color:#000000'><span class='ectt-1000'>,</span></span><span style='color:#000000'> <span class='ectt-1000'>chunk)</span> </span><span class='ecit-1000'> </span><span style='color:#000000'><span class='ecit-1000'>#</span></span><span style='color:#000000'> <span class='ecit-1000'>(3)</span></span></pre>
   
<!-- l. 160 --><p class='indent'>   Notice that Step (4) of the method <span class='obeylines-h'><span class='verb'><span class='ectt-1000'>record_send_and_play()</span></span></span> extracts from the buffer an
unpacked<span class='footnote-mark'><a href='#fn5x0' id='fn5x0-bk'><sup class='textsuperscript'>5</sup></a></span><a id='x1-3036f5'></a>
chunk. The chunks are buffered in Step (3) of the method <span class='obeylines-h'><span class='verb'><span class='ectt-1000'>receive_and_buffer()</span></span></span>.
Note also that Step (1) of <span class='obeylines-h'><span class='verb'><span class='ectt-1000'>receive_and_buffer()</span></span></span> is a blocking method that should
return with every new received chunk.
</p>
   <h3 class='sectionHead'><span class='titlemark'>3   </span> <a id='x1-40003'></a>Deliverables</h3>
<!-- l. 190 --><p class='noindent'>
</p>
   <h4 class='likesubsectionHead'><a id='x1-5000'></a>Find your minimum buffering time</h4>
<!-- l. 191 --><p class='noindent'>Determine, experimentally:
     </p><ol class='enumerate1'>
<li class='enumerate' id='x1-5002x1'>The minimum artificial latency that you must configure in your InterCom
     instance to communicate with your groupmate without lossing chunks,
     when he is in a different<span class='footnote-mark'><a href='#fn6x0' id='fn6x0-bk'><sup class='textsuperscript'>6</sup></a></span><a id='x1-5003f6'></a>
     local network. <a href='https://vicente-gonzalez-ruiz.github.io/about_ping/'>Ping</a> can help to estimate the latency.
     </li>
<li class='enumerate' id='x1-5006x2'>Repeat  the  previous  experiment  using  only  localhost  (transmiting  the
     chunk between the loopback network adapter), but adding some jitter with
     the tool <a href='https://vicente-gonzalez-ruiz.github.io/about_tc/'><span class='ectt-1000'>tc</span></a>. If <span class='ectt-1000'>tc </span>is not avaiable in your OS, you can use any other similar
     tool.</li></ol>
                                                                  

                                                                  
<!-- l. 205 --><p class='indent'>   You can quantify the <a href='https://en.wikipedia.org/wiki/Quality_of_experience'>QoE</a> using the following classification: </p>
     <ul class='itemize1'>
     <li class='itemize'><span class='ecbx-1000'>Perfect</span>: no loss or delay can be perceived.
     </li>
     <li class='itemize'><span class='ecbx-1000'>Good</span>: if you detect some minimal distortion in the rendering of the sound.
     </li>
     <li class='itemize'><span class='ecbx-1000'>Acceptable</span>: when the effects of the latency are noticeable, but you can
     communicate with your interlocutor.
     </li>
     <li class='itemize'><span class='ecbx-1000'>Bad</span>: you are able to recognize only small parts of the received audio.
     </li>
     <li class='itemize'><span class='ecbx-1000'>No way</span>: when most of the time only silence is heard.</li></ul>
<!-- l. 217 --><p class='indent'>   An example of a notebook related to this milestone can be found <a href='https://github.com/Tecnologias-multimedia/InterCom/blob/master/docs/Hidding_the_Network_Jitter__example.ipynb'>here</a>.
   </p><div class='thebibliography'>
   <p class='bibitem'><span class='biblabel'>
 [1]<span class='bibsp'>   </span></span><a id='Xdordal2020intro'></a>Peter L. Dordal. <a href='http://intronetworks.cs.luc.edu/current/ComputerNetworks.pdf'><span class='ecti-1000'>An Introduction to Computer Networks</span></a>. 2020.
   </p>
   <p class='bibitem'><span class='biblabel'>
 [2]<span class='bibsp'>   </span></span><a id='XKurose-Ross'></a>James F.  Kurose  and  Keith W.  Ross.     <a href='https://docs.google.com/viewer?a=v&amp;pid=sites&amp;srcid=Z2FyZGl2aWR5YXBpdGguYWMuaW58aXQyMDE0LTIwMTh8Z3g6OTY5ZDcxZjRmZDBkYzI3'><span class='ecti-1000'>Computer  Networking:  A
   </span><span class='ecti-1000'>Top-Down Approach Featuring the Internet</span></a>. Pearson, 2013.
   </p>
   <p class='bibitem'><span class='biblabel'>
 [3]<span class='bibsp'>   </span></span>
   <a id='XStallings'></a>William Stallings. <a href='https://memberfiles.freewebs.com/00/88/103568800/documents/Data.And.Computer.Communications.8e.WilliamStallings.pdf'><span class='ecti-1000'>Data and Computer Communications</span></a>. Pearson/Prentice
   Hall, 2007.
   </p>
   <p class='bibitem'><span class='biblabel'>
 [4]<span class='bibsp'>   </span></span><a id='XTanenbaum'></a>Andrew S. Tanenbaum. <a href='https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwj9857DgLvsAhUTA2MBHTJfCZ4QFjAAegQIBBAC&amp;url=https%3A%2F%2Fdocs.google.com%2Fviewer%3Fa%3Dv%26pid%3Dsites%26srcid%3DZGVmYXVsdGRvbWFpbnxza21pbmh8Z3g6NjQxMTI2MmYxMTAwZmNjZQ&amp;usg=AOvVaw3m5WEH7H2923_hOFl1e-W-'><span class='ecti-1000'>Computer Networks</span></a>. Prentice Hall, 2011.
</p>
   </div>
                                                                  

                                                                  
   <div class='footnotes'><a id='x1-2003x1'></a>
<!-- l. 34 --><p class='indent'>     <span class='footnote-mark'><a href='#fn1x0-bk' id='fn1x0'><sup class='textsuperscript'>1</sup></a></span><span class='ecrm-0800'>Something that is not available to normal network users.</span></p><a id='x1-3003x2'></a>
<!-- l. 62 --><p class='indent'>     <span class='footnote-mark'><a href='#fn2x0-bk' id='fn2x0'><sup class='textsuperscript'>2</sup></a></span><span class='ecrm-0800'>Usually implemented with random access buffers.</span></p><a id='x1-3005x2'></a>
<!-- l. 74 --><p class='indent'>     <span class='footnote-mark'><a href='#fn3x0-bk' id='fn3x0'><sup class='textsuperscript'>3</sup></a></span><span class='ecrm-0800'>Implementation tip: in a system where for each recorded chunk a chunk must be
</span><span class='ecrm-0800'>also played, a delay in the playback can be generated by sending zero-chunks to the
</span><span class='ecrm-0800'>DAC and then, after the delay, start sending the received chunk of audio, in the right
</span><span class='ecrm-0800'>order.</span></p><a id='x1-3020x4'></a>
<!-- l. 125 --><p class='noindent'><span class='footnote-mark'><a href='#fn4x0-bk' id='fn4x0'><sup class='textsuperscript'>4</sup></a></span><span class='ecrm-0800'>Those chunks that have not been received on time or never have been received.</span></p><a id='x1-3037x2'></a>
<!-- l. 163 --><p class='indent'>     <span class='footnote-mark'><a href='#fn5x0-bk' id='fn5x0'><sup class='textsuperscript'>5</sup></a></span><span class='ecrm-0800'>Chunks will be compressed in a posterior milestone, and uncompressing is performed in this
</span><span class='ecrm-0800'>step.</span></p><a id='x1-5004x6'></a>
<!-- l. 196 --><p class='noindent'><span class='footnote-mark'><a href='#fn6x0-bk' id='fn6x0'><sup class='textsuperscript'>6</sup></a></span><span class='ecrm-0800'>Different to the network in which you are using InterCom.</span></p>                                        </div>
 
</body> 
</html>