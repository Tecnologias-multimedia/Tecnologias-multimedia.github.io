\input{../definitions}
\title{\TM{} - Study Guide - Milestone 13: Overlapped DWT (I)}

\maketitle

\section{Description}

\subsection{\href{https://en.wikipedia.org/wiki/Lapped_transform}{Overlapped transforms} for minimizing the distortion}
Transform coding implies to split the signal into chunks, and to
compute the transform of each chunk. When the output coefficients are
quantized, it is possible that significative (and unpleasant)
distortions may appear between the border frames of the chunks (see
the Fig~\ref{fig:3_chunks}).

\begin{figure}
  \centering
  \begin{tabular}{cc}
    \svg{3_chunks}{500} & \svg{without}{500} \\
    \svg{extended}{500} & \svg{reconstructed}{500} \\
  \end{tabular}
  \caption{On the top-left, three consecutive chunks of a real mono
    audio sequence. On the top-right, the reconstruction of the chunks
    without overlapping. On the bottom-left, the extended chunk. On
    the bottom-right, the reconstruction of the extended chunk. See
    this
    \href{https://github.com/Tecnologias-multimedia/intercom/blob/master/docs/quantization_DWT.ipynb}{notebook}.}
  \label{fig:3_chunks}
\end{figure}

\begin{figure}
  \centering
  \svg{graphics/overlapping}{800}
  \caption{Chunks overlapping. Notice that $a$ data is repeated in the
    extended chunks $C_0$ and $C_1$. Something similar happens with
    $b$ data.}
  \label{fig:overlapping}
\end{figure}

\begin{figure}
  \centering
  \svg{graphics/subbands}{700}
  \caption{Structure in the DWT domain of an extended chunk. $o$ is
    the number of frames to overlap between adajacent chunks. $C[:o]$
    represents the first $o$ framees of the chunk $C$ and $C[-o:]$ the
    last $x-o$ frames of chunk C, where $x$ is the number of frames in
    $C$:}
  \label{fig:subbands}
\end{figure}

One solution to avoid signal discontinuitites between chunks is to
overlap the chunks (see Fig.~\ref{fig:overlapping}). Thus, the current
($i$-th) chunk uses also the last frames of the previous ($(i-1)$-th)
chunk and the first frames of the next ($(i+1)$-th) chunk to compute
the transform of the current extended ($i$-th) chunk (see the
Fig.~\ref{fig:subbands}). This has been described in the following
algorithm:

\subsection*{Encoder:}
\begin{enumerate}
\item For $i\in\{0,1,\cdots\}$:   
  \begin{enumerate}               
  \item Input chunks $C_{i-1}$, $C_i$ and $C_{i+1}$.
  \item $D_i \leftarrow \text{DWT}(C_{i-1}[-o:]|C_i|C_{i+1}[:o])$,
    where $D_i$ is the decomposition of the $i$-th extended chunk,
    $\cdot|\cdot$ denotes the concatenation of frames operator,
    defined by
    \begin{equation}
      a|b = \{a,b\},
    \end{equation}
    and $C_{i-1}[-o:]|C_i|C_{i+1}[:o]$ is the $i$-th extended chunk,
    where $o$ is the overlapped area size, and $C[:o]$ the first $o$
    frames of the chunk $C$, and $C[-o:]$ the last $o$ frames.
  \item Send $D_i$.
  \end{enumerate}
\end{enumerate}

Notice that we sent for each chunk $2o+x$ frames, where $x$ is the
number of frames/chunk.

\subsection*{Decoder:}
\begin{enumerate}
\item For $i\in\{0,1,\cdots\}$:
  \begin{enumerate}
  \item Receive $D_i$.
  \item Perform $C_{i-1}[-o:]|C_i|C_{i+1}[:o]\leftarrow\text{DWT}^{-1}(D_i)$.
  \item Output $C_i$.
  \end{enumerate}
\end{enumerate}

This idea has been implemented in this
\href{https://github.com/Tecnologias-multimedia/intercom/blob/master/docs/overlapped_DWT_I.ipynb}{notebook},
and the result can be seen in the Fig.~\ref{fig:3_chunks}.

\subsection{Reducing the data overhead}

As it can be seen in the Fig.~\ref{fig:overlapping}, the previous
algorithm sends twice the DWT coefficients of the overlapped areas. To
avoid this waste of bandwidth, we can implement:

\subsection*{Encoder:}
\begin{enumerate}
\item For $i\in\{0,1,\cdots\}$:
  \begin{enumerate}
  \item Input $C_i$ and $C_{i+1}$.
  \item $D_i \leftarrow \text{DWT}(C_i[o:]|C_{i+1}[:o])$, where
    $C[o:]$ the last $x-o$ frames of the chunk $C$, and
    $C_i[o:]|C_{i+1}[:o]$ is the $i$-th right-only extended chunk.
    \item Send $D_i$.
  \end{enumerate}
\end{enumerate}

Notice that now, the number of sent coefficients is $x$.

\subsection*{Decoder:}
\begin{enumerate}
\item For $i\in\{0,1,\cdots\}$:
  \begin{enumerate}
  \item Receive $D_i$.
  \item Compute $C_i[o:]|C_{i+1}[:o]\leftarrow\text{DWT}^{-1}(D_i)$.
  \item Output $C_{i-1}[:o]|C_i[o:]$.
  \end{enumerate}
\end{enumerate}

Notice that the only that changes between this codec and the previous
one is that now, the inverse transform of the extended chunks uses the
last coefficients of the previous extended chunk. This idea has been
checked in the
\href{https://github.com/Tecnologias-multimedia/intercom/blob/master/docs/overlapped_DWT_II.ipynb}{notebook}.

\section{What you have to do?}

\begin{enumerate}
\item In a module named overlapped\_temporal\_decorrelate.py, inherit
  the class Temporal\_decorrelation and create a class named
  Overlapped\_temporal\_decorrelation.
\item Compare the RD (Rate/Distortion) curves with the previous one.
\end{enumerate}

\section{Timming}

Please, present your results in one week.

\section{Deliverables}

The module overlapped\_temporal\_decorrelate.py. Store it at the
\href{https://github.com/Tecnologias-multimedia/intercom}{root
  directory} of your InterCom's repo.

\section{Resources}

\bibliography{maths,data-compression,DWT,audio-coding}
