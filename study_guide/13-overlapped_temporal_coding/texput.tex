\input{../definitions}
\title{\TM{} - Study Guide - Milestone 13: Overlapped DWT}

\maketitle

\section{Description}

\subsection{\href{https://en.wikipedia.org/wiki/Lapped_transform}{Overlapped block transforms} for minimizing the distortion}
Transform coding implies to split the signal into blocks of data
(chunks), and to compute the transform of each chunk. When the output
coefficients are quantized, it is possible that significative (and
unpleasant) distortions may appear in the border frames of the chunks
(see Fig~\ref{fig:3_chunks}). This is a consequence of that in the
prediction step used by the DWT in the limits of the chunks generate
different predictions at the beginning and the end of the chunks.

\begin{figure}
  \centering
  \begin{tabular}{cc}
    \svg{3_chunks}{500} & \svg{without}{500} \\
    \svg{extended}{500} & \svg{reconstructed}{500} \\
  \end{tabular}
  \caption{On the top-left, three consecutive chunks of a real mono
    audio sequence. On the top-right, the reconstruction of the chunks
    without overlapping. On the bottom-left, the extended central chunk. On
    the bottom-right, the reconstruction of the extended chunk. See
    this
    \href{https://github.com/Tecnologias-multimedia/intercom/blob/master/docs/quantization_DWT.ipynb}{notebook}.}
  \label{fig:3_chunks}
\end{figure}

One solution to avoid signal discontinuitites between chunks is to
overlap the chunks. Thus, the current ($i$-th) chunk uses also the
last frames of the previous ($(i-1)$-th) chunk and the first frames of
the next ($(i+1)$-th) chunk to compute the transform of the current
extended ($i$-th) chunk (see the Fig.~\ref{fig:subbands}). This has
been described in the following algorithm:

\subsection*{Encoder:}
\begin{enumerate}
\item ${\mathbf C}_{-1}={\mathbf 0}$, a zero chunk.
\item Input ${\mathbf C}_0$.
\item For $i\in\{0,1,\cdots\}$:   
  \begin{enumerate}               
  \item Input ${\mathbf C}_{i+1}$.
  \item Build extended chunk ${\mathbf E}\leftarrow {\mathbf
    C}_{i-1}[-o:]|{\mathbf C}_i|{\mathbf C}_{i+1}[:o]$, where
    $\cdot|\cdot$ denotes the concatenation of chunks, $o$ is the
    overlapped area size in frames, ${\mathbf C}_{i-1}[-o:]$ the last
    $o$ frames of chunk ${\mathbf C}_{i-1}$, and ${\mathbf
      C}_{i+1}[:o]$ are the first $o$ frames of the chunk ${\mathbf
      C}_{i+1}$.
  \item Compute decomposition ${\mathbf D}_i \leftarrow
    \text{DWT}^l({\mathbf E})$, where $l$ is the number of levels of
    the DWT ($l=2$ in the Fig.~\ref{fig:subbands}).
  \item Output decomposition ${\mathbf D}_i$.
  \item ${\mathbf C}_{i-1}\leftarrow {\mathbf C}_i$.
  \item ${\mathbf C}_i\leftarrow {\mathbf C}_{i+1}$.
  \end{enumerate}
\end{enumerate}

Notice that we are following the
\href{https://numpy.org/doc/stable/reference/}{NumPy}~\cite{numpy,harris2020array}
\href{https://www.pythoninformer.com/python-libraries/numpy/index-and-slice/}{slicing}
notation.

%Notice that we are sending for each chunk $2o+x$ coefficients
%(stereo-coefficients, in the case of using 2 chanels), where $x$ is
%the number of frames/chunk.

\subsection*{Decoder:}
\begin{enumerate}
\item For $i\in\{0,1,\cdots\}$:
  \begin{enumerate}
  \item Input decomposition ${\mathbf D}_i$.
  \item Compute extended chunk ${\mathbf E}\leftarrow\text{DWT}^{-l}({\mathbf D}_i)$.
  \item Output chunk ${\mathbf C}_i={\mathbf E}[o:-o]$.
  \end{enumerate}
\end{enumerate}

%\begin{figure}
%  \centering
%  \svg{graphics/overlapping2}{800}
%  \caption{Chunks overlapping. Notice that $a$ data is repeated in the
%    extended chunks $C_0$ and $C_1$. Something similar happens with
%    $b$ data.}
%  \label{fig:overlapping2}
%\end{figure}

\begin{figure}
  \centering
  \svg{graphics/subbands}{550}
  \caption{Structure in the DWT domain of an extended chunk for
    $l=2$. $o$ is the number of overlapped frames between adajacent
    chunks. ${\mathbf C}_{i-1}[-o:]$ represents the last $o$ frames of
    chunk ${\mathbf C}_{i-1}$, and ${\mathbf C}_{i+1}[:o]$ the first
    $o$ frames of the chunk ${\mathbf C}_{i+1}$.}
  \label{fig:subbands}
\end{figure}

This idea has been implemented in this
\href{https://github.com/Tecnologias-multimedia/intercom/blob/master/docs/overlapped_DWT_I.ipynb}{notebook},
and the result can be seen in the Fig.~\ref{fig:3_chunks}.

\subsection{Reducing the data overhead}
\label{sec:reducing}

Unfortunately, the previous algorithm sends twice the DWT coefficients
of the overlapped areas (in the Fig.~\ref{fig:subbands}, $\{{\mathbf
  D}_i.{\mathbf l}^2[-o/4:], {\mathbf D}_i.{\mathbf l}^2[:o/4],
{\mathbf D}_i.{\mathbf h}^2[-o/4:], {\mathbf D}_i.{\mathbf
  h}^2[:o/4], {\mathbf D}_i.{\mathbf h}^1[-o/2:], {\mathbf
  D}_i.{\mathbf h}^1[:o/2]\}$). To avoid this waste of bandwidth, we
can reuse the received coefficients of the overlapped areas. This
procedure has been described in the Fig.~\ref{fig:overlapping}, and,
as it can be seen, the encoding algorithm is identical to the previous
one except in that only the central (stereo) coefficients are
sent. The rest of coefficients that are needed to compute the inverse
transform are extracted from the neighbor chunks (represented in the
DWT domain). Notice that now, the number of sent coefficients is
$\text{len}({\mathbf C}_i)$, the number of samples in ${\mathbf C}_i$.

\begin{figure}
  \centering
  \svg{graphics/overlapping}{800}
  \caption{Block overlapping in the DWT domain for $l=2$. Only the
    shadded coefficients are transmitted. Notice that, to be
    reconstructed, each chunk depends on some coefficients of the
    adjacent blocks (only some dependencies have been indicated).}
  \label{fig:overlapping}
\end{figure}

%\subsection*{Encoder:}
%\begin{enumerate}
%\item For $i\in\{0,1,\cdots\}$:
%  \begin{enumerate}
%  \item Input $C_i$ and $C_{i+1}$.
%  \item $D_i \leftarrow \text{DWT}(C_i[o:]|C_{i+1}[:o])$, where
%    $C[o:]$ the last $x-o$ frames of the chunk $C$, and
%    $C_i[o:]|C_{i+1}[:o]$ is the $i$-th right-only extended chunk.
%    \item Send $D_i$.
%  \end{enumerate}
%\end{enumerate}

The codec now can be described by:

\subsection*{Encoder:}
\begin{enumerate}
\item ${\mathbf C}_{-1}={\mathbf 0}$, a zero chunk.
\item Input ${\mathbf C}_0$.
\item For $i\in\{0,1,\cdots\}$:   
  \begin{enumerate}               
  \item Input ${\mathbf C}_{i+1}$.
  \item Build extended chunk ${\mathbf E}\leftarrow {\mathbf
    C}_{i-1}[-o:]|{\mathbf C}_i|{\mathbf C}_{i+1}[:o]$.
  \item Compute decomposition ${\mathbf D}_i \leftarrow
    \text{DWT}^l({\mathbf E})$.
  \item Output decomposition subset
    $\Big\{{\mathbf D}_i.{\mathbf l}^l[\frac{o}{2^l}:-\frac{o}{2^l}], {\mathbf
      D}_i.{\mathbf h}^l[\frac{o}{2^l}:-\frac{o}{2^l}], {\mathbf D}_i.{\mathbf
      h}^{l-1}[\frac{o}{2^{l-1}}:-\frac{o}{2^{l-1}}], \cdots, {\mathbf D}_i.{\mathbf
      h}^1[\frac{o}{2^1}:-\frac{o}{2^1}]\Big\}$.
  \item ${\mathbf C}_{i-1}\leftarrow {\mathbf C}_i$.
  \item ${\mathbf C}_i\leftarrow {\mathbf C}_{i+1}$.
  \end{enumerate}
\end{enumerate}

%\begin{enumerate}
%\item For $i\in\{0,1,\cdots\}$:   
%  \begin{enumerate}               
%  \item Input chunk $C_i$.
%  \item Compute decomposition $D_i \leftarrow \text{DWT}^l(C_i)$.
%  \item Send $D_i$.
%  \end{enumerate}
%\end{enumerate}

\subsection*{Decoder (ignores overlapping):}
This decoder ignores the adjacent chunks in the DWT domain, but notice that it uses the right coefficients (those computed using overlapping chunks). This should provide reconstructions of the chunks with a higher quality that in the previous milestone.
\begin{enumerate}
\item For $i\in\{0,1,\cdots\}$:
  \begin{enumerate}
  \item Input decomposition subset ${\mathbf D}_i$.
  \item Compute chunk ${\mathbf C}_i\leftarrow\text{DWT}^{-l}({\mathbf D}_i)$.
  \item Output ${\mathbf C}_i$.
  \end{enumerate}
\end{enumerate}

\subsection*{Decoder (uses overlapping):}

\begin{enumerate}
\item ${\mathbf D}_{-1}={\mathbf 0}$.
\item Input decomposition ${\mathbf D}_0$.
\item For $i\in\{0,1,\cdots\}$:
  \begin{enumerate}
  \item Input decomposition ${\mathbf D}_{i+1}$.
  \item Build extended decomposition ${\mathbf E}_i =
    {\mathbf D}_{i-1}.{\mathbf l}^l[-\frac{o}{2^l}:]|{\mathbf D}_i.{\mathbf l}^l|{\mathbf D}_{i+1}.{\mathbf l}^l[:\frac{o}{2^l}]|{\mathbf D}_{i-1}.{\mathbf h}^l[-\frac{o}{2^l}:]|{\mathbf D}_i.{\mathbf h}^l|{\mathbf D}_{i+1}.{\mathbf h}^l[:\frac{o}{2^l}]|\cdots|{\mathbf D}_{i-1}.{\mathbf h}^1[-\frac{o}{2^1}:]|{\mathbf D}_i.{\mathbf h}^1|{\mathbf D}_{i+1}.{\mathbf h}^1[:\frac{o}{2^1}]$.
  \item Compute extended chunk ${\mathbf C}_i\leftarrow\text{DWT}^{-l}({\mathbf E}_i)$.
  \item Output ${\mathbf C}_i[o:-o]$.
  \item ${\mathbf D}_{i-1} \leftarrow {\mathbf D}_i$.
  \item ${\mathbf D}_i \leftarrow {\mathbf D}_{i+1}$.
  \end{enumerate}
\end{enumerate}

%Notice that the only that changes between this codec and the previous
%one is that now, the inverse transform of the extended chunks uses the
%last coefficients of the previous extended chunk. This idea has been
%checked in the
%\href{https://github.com/Tecnologias-multimedia/intercom/blob/master/docs/overlapped_DWT_II.ipynb}{notebook}.

\section{What you have to do?}

\begin{enumerate}
\item In a module named \verb|temporal_overlapped_DWT_coding.py|,
  inherit from \verb|temporal_no_overlapped_DWT_coding.py| the class
  \verb|Temporal_No_Overlapped_DWT|, and create a class named
  \verb|Temporal_Overlapped_DWT| which must implement the codec
  described in the Section~\ref{sec:reducing}.
\item Build the RD curves to see how this improvement impacts on the
  efficiency of intercom.
\item Determine which decoder is better from the RD perspective.
\item Which is the latency of the encoder and the decoders, measured
  in chunk-times?
\end{enumerate}

\section{Timming}

Please, present your results in two weeks.

\section{Deliverables}

\begin{enumerate}
\item The module \verb|temporal_overlapped_DWT_coding.py|. Store it at
  the
  \href{https://github.com/Tecnologias-multimedia/intercom/src}{\texttt{src}
    directory} of your InterCom's repo.
\item The RD curves and the information required to regenerate them.
\end{enumerate}
  
\section{Resources}

\bibliography{python}
