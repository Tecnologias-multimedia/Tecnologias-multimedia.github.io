\input{../definitions}
\title{\TM{} - Study Guide - Milestone 13: Overlapped DWT (II)}

\maketitle

\section{Description}

The inverse ODWT (Overlapped DWT) uses the coefficientes generated by
the overlapped areas between chunks to remove the chunk
discontinuities when quantization is applied to the transform
coefficients. In the previous milestone we use an implementation that
sends twice the overlapped coefficients, which definetively is a
source of redundancy.

To solve this problem, we can:

\subsection*{Encoder:}
\begin{enumerate}
\item For $i\in\{0,1,\cdots\}$:
  \begin{enumerate}
  \item Input chunks $i$ and $i+1$, $C_i$ and $C_{i+1}$.
  \item Let's the overlapped area size $o$, $C[:o]$ the first $o$
    samples of the chunk $C$, and $C[o:]$ the result of removing the
    first $o$ samples.
  \item $D_i \leftarrow \text{DWT}(C_i[o:]|C_{i+1}[:o])$, where $D_i$ is the
    decomposition of the $i$-th right-shifted chunk, $\cdot|\cdot$ denotes
    the concatenation of samples operator, defined by
    \begin{equation}
      a|b = \{a,b\},
    \end{equation}
    and $C_i[o:]|C_{i+1}[:o]$ is the $i$-th right-shifted chunk.
    \item Send $D_i$.
  \end{enumerate}
\end{enumerate}

\subsection*{Decoder:}
\begin{enumerate}
\item For $i\in\{0,1,\cdots\}$:
  \begin{enumerate}
  \item Receive $D_i$.
  \item Perform $C_i[o:]|C_{i+1}[:o]\leftarrow\text{DWT}^{-1}(D_i)$.
  \item Output $C_{i-1}[:o]|C_i[o:]$.
  \end{enumerate}
\end{enumerate}

In the previous milestone we have sent the DWT coefficients of the
overlapped areas twice. This milestone removes this redundancy. See
\href{https://github.com/Tecnologias-multimedia/intercom/blob/master/docs/overlapped_DWT_II.ipynb}{notebook}.

\section{What you have to do?}

\begin{enumerate}
\item In a module named overlapped\_temporal\_decorrelate\_II.py, inherit
  the class Temporal\_decorrelation and create a class named
  Overlapped\_temporal\_decorrelation.
\item Compare the RD (Rate/Distortion) curves with the previous one.
\end{enumerate}

\section{Timming}

Please, present your results in one week.

\section{Deliverables}

The module overlapped\_ttemporal\_decorrelate.py. Store it at the
\href{https://github.com/Tecnologias-multimedia/intercom}{root
  directory} of your InterCom's repo.

\section{Resources}

\bibliography{maths,data-compression,DWT,audio-coding}

\begin{comment}

  The Figure~\ref{fig:transform_coding} shows the stages that are
  tipycally involved in a transform-based signal compression system.

\begin{figure}
  \begin{center}
\begin{verbatim}
   s   +---+   w    +---+   k    +---+    c
 ----->| T |------->| Q |------->| E |-----------+
  (s)  +---+  (s)   +---+  (~s)  +---+   (~s)    |
samples   coefficients   indexes      code-words ~
                                                 :
                                                 ~
   ~s  +---+    w   +---+   k    +---+           |
 <-----| t |<-------| q |<-------| D |<----------+
  (~s) +---+  (~s)  +---+  (~s)  +---+
approx.    quantized     indexes
samples   coefficients
\end{verbatim}                
  \end{center}
  \caption{Common data-flow used un Transform Coding. $s$ represents
    the signal to compress, $\tilde{s}$ the lossy version of the
    reconstructed signal, $T$ the (forward) transform (which takes blocks of
    samples) producing blocks of coefficients $w$, $Q$ the scalar
    quantization stage (which takes single coefficients) producing
    quantization indexes $k$, $E$ the entropy encoder (which in our
    case (DEFLATE) works with blocks of coefficients) producing
    code-words $c$, $D$ the entropy decoder, $q$ the decuantization
    stage, and $t$ the inverse (or backward) transform. PCM stands for Puse Code
    Modulation and DEFLATE is the technique used to find a compact
    representation of the quantized coefficients.}
  \label{fig:transform_coding}
\end{figure}
\end{comment}

