\title{\href{https://www.ual.es/estudios/grados/presentacion/plandeestudios/asignatura/4015/40154321?idioma=zh_CN}{Tecnolog√≠as Multimedia} - Study Guide - Milestone 10: Quantizing}

\maketitle

\section{Description}

At the hardware level, the samples of audio are represented using PCM
(Pulse Code Modulation). In a PCM sample, the number of levels that
the signal can take depends on the number of bits/sample (16 bits in
our case). This discussion is reffered only to the Quantization of
digital signals.

Another key aspect to consider is that the processing that the Human
Auditory System (HAS) performs to understand audio signals has several
sources of psychic redundancy. One of these sources of redundancy is
the finite number of different volumen levels that we can recognize.

Scalar Quantization (SQ) is the process of decreasing the number of
levels that a signal can take~\cite{sayood}.  Vector Quantization (VQ)
is similar, but is applied tuples of
samples~\cite{foundationsofsignalprocessing}. SQ is used when the
samples are decorrelated because is much faster to compute than VQ.

Quantizers can be classified into uniform and non-uniform. An uniform
quantizator distributes the available representation levels uniformely
over the range of input values. Non-uniform quantizers use different
density of representation levels to those intervals of input values
that, for example, occur more often. Non-uniform quantizers can also
be classified into static and adaptive quantizers. In the first case,
the distribution of the representation levels remain constant during
the quantization stage, and in the second case, the densities are
adapted dinamically to the characteristics of the input signal. In
this milestone we will use an uniform Midtread scalar quantizer. See
this Jupyter notebook for more information.

In most lossy compression systems, Quantization is the only source of
distortion~\cite{taubman}. This irreversible loss of information
depends basically of how many bits are dedicated to represent any
possible output (quantized) sample. The higher the number of output
bits per sample, the lower the quantization errora and therefore, the
distortion.

The number of representation levels provided by a quantizer depends
basically on the so called Quantization Step or $\Delta$. The higher
the $\Delta$, the smaller the number of representation levels, and
therefore, the higher the distortion. Obviously, the smaller the
number of representation levels, the smaller the output bit
bit-rate. The control of the bit-rate through the control of $\Delta$
is a technique that can be used in transmission systems to minimize
the jitter and the loss of packets.

\section{What you have to do?}

\begin{enumerate}
\item Create a class named \texttt{Quantization}, that inherits from
  \texttt{Buffer} (the class implemented in the previous milestone),
  in which the methods $\mathtt{pack()}$ and $\mathtt{unpack()}$ are
  overriden to compress and decompress the chunks. Use the Python's
  standard library
  \href{https://docs.python.org/3/library/zlib.html}{\texttt{zlib}}. Store
  this class in a module named \texttt{compress.py}.
\item Compress (and decompress) each chunk as a unit (each compressed
  chunk will be transmitted in a different UDP packet). In order to
  increase slightly the
  \href{https://en.wikipedia.org/wiki/Data_compression_ratio}{(data)
    compression ratio}, reorder the samples as it is shown in the
  Figure~\ref{fig:reordering}.
\item Describe the QoE as a function of the transmission bit-rate
  (determine the transmission bit-rates that generate each possible
  QoE clasiffication).
\end{enumerate}

\section{Timming}

Please, finish this milestone at most in one week.

\section{Deliverables}

Create a Python module named \texttt{compress.py} and store it in the
\href{https://github.com/Tecnologias-multimedia/intercom}{root
  directory} of your \texttt{intercom}'s repo.

\section{Resources}

\bibliography{text-compression}
