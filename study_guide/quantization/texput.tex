\title{\href{https://www.ual.es/estudios/grados/presentacion/plandeestudios/asignatura/4015/40154321?idioma=zh_CN}{Tecnolog√≠as Multimedia} - Study Guide - Milestone 10: Quantizing}

\maketitle

\section{Description}

At the hardware level, the samples of audio are represented using \href{https://en.wikipedia.org/wiki/Pulse-code_modulation}{PCM
(Pulse Code Modulation)}. In a PCM sample, the number of levels that
the signal can take depends on the number of bits/sample (16 bits in
our case). This discussion is reffered only to the \href{https://en.wikipedia.org/wiki/Quantization_(signal_processing)}{quantization} of
digital signals.

Another key aspect to consider is that the processing that the Human
Auditory System (HAS) performs to understand audio signals has several
sources of psychic redundancy. One of these sources of redundancy is
the finite number of different volumen levels that we can recognize.

Scalar Quantization (SQ) is the process of decreasing the number of
levels that a signal can take~\cite{sayood}.  Vector Quantization (VQ)
is similar, but is applied tuples of
samples~\cite{foundationsofsignalprocessing}. SQ is used when the
samples are decorrelated because is much faster to compute than VQ.

Quantizers can be classified into uniform
and \href{https://nptel.ac.in/content/storage2/courses/117104069/chapter_5/5_5.html}{non-uniform}. An
uniform quantizator distributes the available representation levels
uniformely over the range of input values. Non-uniform quantizers use
different density of representation levels to those intervals of input
values that, for example, occur more often. Non-uniform quantizers can
also be classified into static and adaptive quantizers. In the first
case, the distribution of the representation levels remain constant
during the quantization stage, and in the second case, the densities
are adapted dinamically to the characteristics of the input signal. In
this milestone we will use an uniform Midtread scalar quantizer. See
this Jupyter notebook for more information.

In most lossy compression systems, Quantization is the only source of
distortion~\cite{taubman}. This irreversible loss of information
depends basically of how many bits are dedicated to represent any
possible output (quantized) sample. The higher the number of output
bits per sample, the lower the quantization errora and therefore, the
distortion.

The number of representation levels provided by a quantizer depends
basically on the so called Quantization Step or $\Delta$. The higher
the $\Delta$, the smaller the number of representation levels, and
therefore, the higher the distortion. Obviously, the smaller the
number of representation levels, the smaller the output bit
bit-rate. The control of the bit-rate through the control of $\Delta$
is a technique that can be used in transmission systems to minimize
the jitter and the loss of packets.

\section{What you have to do?}

\begin{enumerate}
\item Create a class named \texttt{Quantization}, that inherits from
  \texttt{Buffer} (the class implemented in the previous
  milestone). Store it in a file named \texttt{quantization.py}.
\item Override the methods $\mathtt{pack()}$ and $\mathtt{unpack()}$,
  which should implement:

\begin{pseudocode}{Quantization\_InterCom}{~}
  \PROCEDURE{Pack}{\mathtt{chunk\_number}, \mathtt{chunk}}
  \BEGIN
    \mathtt{quantized\_chunk} \GETS quantize(\mathtt{chunk})\\
    \mathtt{packed\_chunk} \GETS Buffer.pack(\mathtt{chunk_number}, \mathtt{quantized_chunk})\\
    return \mathtt{packed\_chunk}\\
  \END
  \ENDPROCEDURE
  \PROCEDURE{Unpack}{(\mathtt{packed\_chunk})}
  \BEGIN
    \mathtt{chunk\_number}, \mathtt{quantized\_chunk} \GETS Buffer.unpack(\mathtt{packed\_chunk})\\
    \mathtt{chunk} \GETS dequantize(\mathtt{quantized\_chunk})\\
    return \mathtt{chunk\_number}, \mathtt{chunk}
  \END
  \ENDPROCEDURE
\end{pseudocode}

\item Determine the quantization step $\Delta$ used in the
  $\mathtt{quantize()}$ method as a function of the throughput $B$ of
  the communication link. Take into consideration that in real
  intercommunication scenario, $B$ is time-variying and therefore,
  $\Delta = \mathtt{estimation}(B)$, where $\mathtt{estimation()}$
  should use the previously $B$ measured values. Such estimation
  should maximize the QoE.
\end{enumerate}

\section{Timming}

Please, finish this milestone at most in two weeks.

\section{Deliverables}

Create a Python module named \texttt{quantization.py} and store it in
the \href{https://github.com/Tecnologias-multimedia/intercom}{root
  directory} of your \texttt{intercom}'s repo.

\section{Resources}

\bibliography{text-compression}
