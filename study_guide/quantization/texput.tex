\title{\href{https://www.ual.es/estudios/grados/presentacion/plandeestudios/asignatura/4015/40154321?idioma=zh_CN}{Tecnolog√≠as Multimedia} - Study Guide - Milestone 10: Bit-rate Control through Quantization}

\maketitle

\section{Description}

This discussion is reffered only to the
\href{https://en.wikipedia.org/wiki/Quantization_(signal_processing)}{quantization}
of digital signals.

At the hardware level, the samples of audio are usually represented
using \href{https://en.wikipedia.org/wiki/Pulse-code_modulation}{PCM
  (Pulse Code Modulation)}. In a PCM sample, the number of levels that
the signal can take depends on the
\href{https://en.wikipedia.org/wiki/Audio_bit_depth}{number of
  bits/sample} (16 bits in our case).

Another key aspect to consider is that the processing that the
\href{https://en.wikipedia.org/wiki/Auditory_system}{Human Auditory
  System (HAS)} performs to understand audio signals has several
\href{https://en.wikipedia.org/wiki/Psychoacoustics}{sources of
  perceptual redundancy}. One of these sources is the
\href{https://en.wikipedia.org/wiki/Equal-loudness_contour}{finite
  number of different volumen levels that a human being can
  recognize}~\cite{bosi2003intro}. In this milestone we will profit of
that fact to decrease the transmission bit-rate by sacrificing
quality.  In most lossy compression systems, quantization is the only
source of distortion~\cite{taubman2002jpeg2000}.

\href{https://en.wikipedia.org/wiki/Quantization_(signal_processing)}{Scalar
  Quantization} (SQ) is the process of decreasing the number of levels
that a signal can
take~\cite{sayood2017introduction}. \href{https://en.wikipedia.org/wiki/Vector_quantization}{Vector
  Quantization} (VQ) is similar, but is applied tuples of samples at
the same time~\cite{vetterli2014foundations}. SQ is used when the
samples are decorrelated (not in our case, now, this will be true in
the future) because the
\href{https://en.wikipedia.org/wiki/Quantization_(signal_processing)#Rate%E2%80%93distortion_optimization}{coding
  efficiency} provided by VQ is marginal in this
context~\cite{vetterli2014foundations}.

Quantizers can also be classified into
\href{https://en.wikipedia.org/wiki/Quantization_(signal_processing)#Mid-riser_and_mid-tread_uniform_quantizers}{uniform}
and
\href{https://nptel.ac.in/content/storage2/courses/117104069/chapter_5/5_5.html}{non-uniform}~\cite{sayood2017introduction,vetterli2014foundations}. An
uniform quantizer distributes the available representation levels
uniformely over the range of input values. Non-uniform quantizers use
higher density representation levels (more output levels per input
levels) to those intervals of input values that occur
more often. Non-uniform quantizers can also be classified into static
and
\href{https://en.wikipedia.org/wiki/Adaptive_differential_pulse-code_modulation}{adaptive
  quantizers}. In the first case, the
\href{https://en.wikipedia.org/wiki/Probability_distribution}{distribution}
of the representation levels remain constant during the quantization
stage, and in the second case, the densities are adapted dinamically
to the characteristics of the input signal. In this milestone we will
use an
\href{https://en.wikipedia.org/wiki/Quantization_(signal_processing)#Dead-zone_quantizers}{uniform
  dead-zone scalar static quantizer}, which can be implemented
efficiently for digital signals and that provides a good
\href{https://en.wikipedia.org/wiki/Rate%E2%80%93distortion_theory}{rate/distortion}
trade-off. See \href{https://github.com/vicente-gonzalez-ruiz/quantization/blob/master/digital_quantization.ipynb}{this Jupyter notebook} for more information.

The number of representation levels used by a quantizer depends
basically on the so called quantization step, typically denoted by
$\Delta$. The higher the $\Delta$, the smaller the number of
representation levels, and therefore, the higher the distortion
generated by the quantization error (see
\href{https://github.com/vicente-gonzalez-ruiz/quantization/blob/master/digital_quantization.ipynb}{the
  notebook}), and lileky, the smaller the output bit-rate. The control
of the bit-rate through the $\Delta$ values is a technique that can be
used in real-time transmission systems to minimize the jitter and the
loss of packets when
\href{https://en.wikipedia.org/wiki/Network_congestion}{congestion}
occurs.

\section{What you have to do?}

\begin{enumerate}
\item Create a class named Quantization that inherits from
  Compression (the class implemented in the previous
  milestone). Store it in a file named quantize.py.
  
\item Override the methods pack() and unpack(),
  which now whould implement:

\begin{pseudocode}{Quantization\_InterCom}{~}
  \PROCEDURE{pack}{\text{chunk\_number}, \text{chunk}}
  \BEGIN
    \text{quantized\_chunk} \GETS \text{quantize}(\text{chunk})\\
    \text{packed\_chunk} \GETS \text{Buffer.pack}(\text{chunk\_number}, \text{quantized\_chunk})\\
    \text{return}~ \text{packed\_chunk}
  \END
  \ENDPROCEDURE
  \PROCEDURE{unpack}{\text{packed\_chunk}}
  \BEGIN
    \text{chunk\_number}, \text{quantized\_chunk} \GETS \text{Buffer.unpack}(\text{packed\_chunk})\\
    \text{chunk} \GETS \text{dequantize}(\text{quantized\_chunk})\\
    \text{return}~ \text{chunk\_number}, \text{chunk}
  \END
  \ENDPROCEDURE
\end{pseudocode}

\item Determine the quantization step $\Delta$ used in the
  $\text{quantize()}$ method depending on
  the \href{https://en.wikipedia.org/wiki/Throughput}{throughput} $B$
  of the communication link. Your implementation should consider that
  $B$ can be time-variying, and should maximize the QoE.

%\item Determine the quantization step $\Delta$ used in the
%  $\text{quantize()}$ method as a function of the
%  \href{https://en.wikipedia.org/wiki/Throughput}{throughput} $B$ of
%  the communication link. Take into consideration that in a real
%  intercommunication scenario, $B$ is time-variying and therefore,
%  $\Delta = \text{estimation}(B)$, where $\text{estimation()}$
%  should use the previously measured values of $B$. Such estimation
%  should maximize the QoE.
\end{enumerate}

\section{Timming}

Please, finish this milestone at most in two weeks.

\section{Deliverables}

\begin{enumerate}
  \item The Python module named br\_control.py stored in the
    \href{https://github.com/Tecnologias-multimedia/intercom}{root
      directory} of your InterCom's repo.  \item A video demonstration
    of 3 minutes (at most) showing how quantize.py adapts to the
    variations of the throughput of the link (use
    \href{https://man7.org/linux/man-pages/man8/tc.8.html}{tc}).
\end{enumerate}

\section{Resources}

\bibliography{JPEG2000,audio-coding,data-compression,signal-processing}
