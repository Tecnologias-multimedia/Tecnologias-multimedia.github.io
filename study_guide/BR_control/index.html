<!DOCTYPE html> 
<html lang='en-US' xml:lang='en-US'> 
<head> <title>Bit-Rate Control in InterCom</title> 
<meta charset='utf-8' /> 
<meta content='TeX4ht (https://tug.org/tex4ht/)' name='generator' /> 
<meta content='width=device-width,initial-scale=1' name='viewport' /> 
<link href='index.css' rel='stylesheet' type='text/css' /> 
<meta content='index.tex' name='src' /> 
<script>window.MathJax = { tex: { tags: "ams", }, }; </script> 
 <script async='async' id='MathJax-script' src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js' type='text/javascript'></script>  
</head><body>
   <div class='maketitle'>
                                                                  

                                                                  
                                                                  

                                                                  

<h2 class='titleHead'>Bit-Rate Control in InterCom</h2>
 <div class='author'><a href='https://cms.ual.es/UAL/personas/persona.htm?id=515256515553484875'><span class='ecrm-1200'>Vicente González Ruiz</span></a> <span class='ecrm-1200'>- </span><a href='https://cms.ual.es/UAL/universidad/departamentos/informatica/index.htm'><span class='ecrm-1200'>Depto Informática</span></a> <span class='ecrm-1200'>- </span><a href='https://www.ual.es'><span class='ecrm-1200'>UAL</span></a></div><br />
<div class='date'><span class='ecrm-1200'>November 9, 2022</span></div>
   </div>
   <h3 class='likesectionHead' id='contents'><a id='x1-1000'></a>Contents</h3>
   <div class='tableofcontents'>
    <span class='sectionToc'>1 <a href='#description' id='QQ2-1-2'>Description</a></span>
<br />     <span class='subsectionToc'>1.1 <a href='#impact-of-the-link-throughput' id='QQ2-1-3'>Impact of the link throughput</a></span>
<br />     <span class='subsectionToc'>1.2 <a href='#compressing-the-audio-data-with-httpszlibnetzlib' id='QQ2-1-4'>Compressing the audio data with zlib</a></span>
<br />     <span class='subsectionToc'>1.3 <a href='#quantization' id='QQ2-1-6'>Quantization</a></span>
<br />     <span class='subsectionToc'>1.4 <a href='#bit-rate-control-and-distortion' id='QQ2-1-7'>(Bit-) Rate control and distortion</a></span>
<br />     <span class='subsectionToc'>1.5 <a href='#the-current-implementations-for-the-control-of-the-bitrate' id='QQ2-1-8'>The current implementation(s) for the control of the bit-rate</a></span>
<br />    <span class='sectionToc'>2 <a href='#what-do-you-have-to-do' id='QQ2-1-9'>What do you have to do?</a></span>
<br />     <span class='subsectionToc'>2.1 <a href='#estimate-the-bitrate-in-an-internet-link' id='QQ2-1-10'>Estimate the bit-rate in an Internet link</a></span>
<br />     <span class='subsectionToc'>2.2 <a href='#simulate-the-link' id='QQ2-1-11'>Simulate the link</a></span>
<br />     <span class='subsectionToc'>2.3 <a href='#which-dataordering-performs-better' id='QQ2-1-13'>Which data-ordering performs better?</a></span>
<br />     <span class='subsectionToc'>2.4 <a href='#compute-rd-ratedistortion-curves' id='QQ2-1-14'>Compute RD (Rate/Distortion) curves</a></span>
<br />    <span class='sectionToc'>3 <a href='#deliverables' id='QQ2-1-15'>Deliverables</a></span>
<br />    <span class='sectionToc'>4 <a href='#resources' id='QQ2-1-16'>Resources</a></span>
<br />    <span class='sectionToc'><a href='#references'>References</a></span>
   </div>
<!-- l. 11 --><p class='noindent'>
</p>
   <h3 class='sectionHead' id='description'><span class='titlemark'>1   </span> <a id='x1-20001'></a>Description</h3>
                                                                  

                                                                  
<!-- l. 13 --><p class='noindent'>
</p>
   <h4 class='subsectionHead' id='impact-of-the-link-throughput'><span class='titlemark'>1.1   </span> <a id='x1-30001.1'></a>Impact of the link throughput</h4>
<!-- l. 15 --><p class='noindent'>Along with the latency and its variation (jitter), another main aspect to
consider about the <a href='https://en.wikipedia.org/wiki/Telecommunications_link'>transmission link</a> used in an InterCom session is the <a href='https://en.wikipedia.org/wiki/Channel_capacityhttps://en.wikipedia.org/wiki/Network_throughput'>link
throughput</a><span class='footnote-mark'><a href='#fn1x0' id='fn1x0-bk'><sup class='textsuperscript'>1</sup></a></span><a id='x1-3001f1'></a>
that it can provide <span class='cite'>[<a href='#XForouzan'>2</a>, <a href='#XTanenbaum'>6</a>]</span>. This bit-rate depend on the maximum <a href='https://en.wikipedia.org/wiki/Channel_capacity'>capacity</a> (a
characteristic closely related with the available <a href='https://en.wikipedia.org/wiki/Bandwidth_(signal_processing)'>bandwidth</a>) and the <a href='https://en.wikipedia.org/wiki/Network_congestion'>congestion level</a>
(that basically depends on the load) of the link. In general, we can suppose that the
capacity is constant along the time (the bandwidth provided by the link does not
vary with the time). On the contrary, the throughput is time-variying and quite
unpredictable, because it depends on the congestion level that which in turn
depdends on the behaviour of the network users.
</p><!-- l. 37 --><p class='indent'>   In this milestone we are going to measure the impact of the link throughput on the
<a href='https://en.wikipedia.org/wiki/Quality_of_experience'>QoE</a><span class='footnote-mark'><a href='#fn2x0' id='fn2x0-bk'><sup class='textsuperscript'>2</sup></a></span><a id='x1-3002f2'></a>
provided by the current implementation of InterCom (<a href='https://github.com/Tecnologias-multimedia/InterCom/blob/master/src/buffer.py'><span class='ectt-1000'>buffer.py</span></a>). Similarly to the
procedure used for measuring the impact of the latency and the jitter, we will
use <a href='https://man7.org/linux/man-pages/man8/tc.8.html'><span class='ectt-1000'>tc</span></a> <span class='cite'>[<a href='#Xbert2012lartc'>3</a>]</span> to control the amount of data that an InterCom instance will
be allowed to send in a local environment, with the aim of simulating a
real environment. Notice that this upper bound in the bit-rate will also
affect to the loss of chunks because if the link capacity is smaller than the
audio bit-rate (the throughput), sooner of later the link will discard those
chunks that can not be buffered in the retransmission nodes (routers and
switches)<span class='footnote-mark'><a href='#fn3x0' id='fn3x0-bk'><sup class='textsuperscript'>3</sup></a></span><a id='x1-3003f3'></a>.
</p><!-- l. 57 --><p class='noindent'>
</p>
   <h4 class='subsectionHead' id='compressing-the-audio-data-with-httpszlibnetzlib'><span class='titlemark'>1.2   </span> <a id='x1-40001.2'></a>Compressing the audio data with <a href='https://zlib.net/'>zlib</a></h4>
<!-- l. 59 --><p class='noindent'>To reduce the bit-rate, we need some way of compressing the data, action that also
will reduce the throughput in InterCom. The <span class='obeylines-h'><span class='verb'><span class='ectt-1000'>pack()</span></span></span> and the <span class='obeylines-h'><span class='verb'><span class='ectt-1000'>unpack()</span></span></span> methods can
compress and decompress, respectively, the chunks that are processed. To compress
and decompress, we will use a free <a href='https://en.wikipedia.org/wiki/Codec'>codec</a> named <a href='https://en.wikipedia.org/wiki/DEFLATE'>DEFLATE</a>, which is based
on <a href='https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Storer%E2%80%93Szymanski'>LZSS</a> and <a href='https://en.wikipedia.org/wiki/Huffman_coding'>Huffman Coding</a> <span class='cite'>[<a href='#Xnelson96datacompression'>4</a>]</span> (see this <a href='https://github.com/vicente-gonzalez-ruiz/LZ77'>notebook</a> and this <a href='https://vicente-gonzalez-ruiz.github.io/Huffman_coding/'>notebook</a>).
The DEFLATE algorithm is implemented in the Python’s standard library
<a href='https://docs.python.org/3/library/zlib.html'><span class='ectt-1000'>zlib</span></a>.
</p><!-- l. 79 --><p class='indent'>   In order to compare the performance of different alternatives, the avobe methods
are implemented in the following modules, with a different functionality:
</p><!-- l. 83 --><p class='indent'>
     </p><ol class='enumerate1'>
<li class='enumerate' id='x1-4002x1'><a href='https://github.com/Tecnologias-multimedia/InterCom/blob/master/src/DEFLATE_raw.py'><span class='ectt-1000'>DEFLATE_raw.py</span></a>: Compress the raw chunks with DEFLATE.
     </li>
                                                                  

                                                                  
<li class='enumerate' id='x1-4004x2'>
     <!-- l. 88 --><p class='noindent'><a href='https://github.com/Tecnologias-multimedia/InterCom/blob/master/src/DEFLATE_serial.py'><span class='ectt-1000'>DEFLATE_serial.py</span></a>: Compress the chunk after concatenating the
     channels (see Fig. <a href='#x1-4005r1'>1<!-- tex4ht:ref: fig:reordering  --></a>). Notice that with this data-shuffling, the samples
     are not interleaved and the <a href='https://en.wikipedia.org/wiki/Correlation'>correlation</a> between consecutive bytes is
     slighly increased. This should also increase the <a href='https://en.wikipedia.org/wiki/Data_compression_ratio'>(data) compression ratio</a>.
     </p><figure class='figure' id='-sample-reordering-to-create-two-independent-channels-'> 

<div class='center'>
<!-- l. 98 --><p class='noindent'>
</p><!-- l. 99 --><p class='noindent'><div style='text-align:center;'> <img src='graphics/reordering.svg' /> </div>  </p></div>
<a id='x1-4005r1'></a>
<a id='x1-4006'></a>
     <figcaption class='caption'><span class='id'>Figure 1: </span><span class='content'>Sample reordering to create two independent channels.
     </span></figcaption><!-- tex4ht:label?: x1-4005r1  -->
     </figure>
     </li>
<li class='enumerate' id='x1-4008x3'><a href='https://github.com/Tecnologias-multimedia/InterCom/blob/master/src/DEFLATE_serial2.py'><span class='ectt-1000'>DEFLATE_serial2.py</span></a>: Similar to <span class='obeylines-h'><span class='verb'><span class='ectt-1000'>compress_serial.py</span></span></span>, but reseting
     DEFLATE at each new chunk-channel, i.e., compressing each chunk-channel
     independtly. The idea here is to see if DEFLATE is exploiting the redundancy
     between the consecutive channels.
     </li>
<li class='enumerate' id='x1-4010x4'><a href='https://github.com/Tecnologias-multimedia/InterCom/blob/master/src/DEFLATE_byteplanes2.py'><span class='ectt-1000'>DEFLATE_byteplanes2.py</span></a>: Similar to <span class='obeylines-h'><span class='verb'><span class='ectt-1000'>compress_serial.py</span></span></span> (samples are
     de-interleaved), but 2 code-streams are generated, one for the LSB (Low
     Significant Byte) plane and another for the MSB (Most Significant Byte) plane,
     working with 16 bits/sample. The idea here is to see if the MSB can be
     compressed more efficiently because it can contain runs of zeros, especially
     when the audio sequence is <span class='ecti-1000'>quiet</span>.
     </li>
<li class='enumerate' id='x1-4012x5'><a href='https://github.com/Tecnologias-multimedia/InterCom/blob/master/src/DEFLATE_byteplanes3.py'><span class='ectt-1000'>DEFLATE_byteplanes3.py</span></a>: Similar to <span class='obeylines-h'><span class='verb'><span class='ectt-1000'>DEFLATE_byteplanes2.py</span></span></span> but
     considering three byte-planes. This would enable the compression of
     <span class='ecti-1000'>coefficients</span><span class='footnote-mark'><a href='#fn4x0' id='fn4x0-bk'><sup class='textsuperscript'>4</sup></a></span><a id='x1-4013f4'></a>
     that require more than two bytes to be represented.
                                                                  

                                                                  
     </li>
<li class='enumerate' id='x1-4015x6'><a href='https://github.com/Tecnologias-multimedia/InterCom/blob/master/src/DEFLATE_byteplanes4.py'><span class='ectt-1000'>DEFLATE_byteplanes4.py</span></a>: Considers four byte-planes.
     </li>
<li class='enumerate' id='x1-4017x7'><a href='https://github.com/Tecnologias-multimedia/InterCom/blob/master/src/DEFLATE_byteplanes2_interlaced.py'><span class='ectt-1000'>DEFLATE_byteplanes2_interlaced.py</span></a>: Similar to <span class='obeylines-h'><span class='verb'><span class='ectt-1000'>DEFLATE_byteplanes2.py</span></span></span>
     but using the raw chunks (without concatenating the channels).</li></ol>
<!-- l. 133 --><p class='indent'>   Finally, notice that the number of sent UDP packets (that now will be
length-variying) remains constant respect to <span class='obeylines-h'><span class='verb'><span class='ectt-1000'>buffer.py</span></span></span>.
</p><!-- l. 137 --><p class='noindent'>
</p>
   <h4 class='subsectionHead' id='quantization'><span class='titlemark'>1.3   </span> <a id='x1-50001.3'></a>Quantization</h4>
<!-- l. 139 --><p class='noindent'>At the hardware level, the samples of audio are usually represented using
<a href='https://en.wikipedia.org/wiki/Pulse-code_modulation'>Pulse Code Modulation (PCM)</a>. In a PCM sample, the number of levels that
the signal can take depends on the <a href='https://en.wikipedia.org/wiki/Audio_bit_depth'>number of bits/sample</a> (16 bits in our
case).
</p><!-- l. 146 --><p class='indent'>   Another key aspect to consider is that the processing that the <a href='https://en.wikipedia.org/wiki/Auditory_system'>Human Auditory
System (HAS)</a> performs to understand audio signals has several <a href='https://en.wikipedia.org/wiki/Psychoacoustics'><span class='ecti-1000'>sources </span>of
perceptual redundancy</a>. One of these sources is the <a href='https://en.wikipedia.org/wiki/Equal-loudness_contour'>finite number of different
volumen levels that a human being can recognize</a> <span class='cite'>[<a href='#Xbosi2003intro'>1</a>]</span>. In this milestone we
will profit of that fact to decrease the transmission bit-rate by sacrificing
quality. In most <a href='https://en.wikipedia.org/wiki/Lossy_compression'>lossy compression</a> schemes, quantization is the only source of
<a href='https://en.wikipedia.org/wiki/Distortion'>distortion</a> <span class='cite'>[<a href='#Xtaubman2002jpeg2000'>7</a>]</span>.
</p><!-- l. 161 --><p class='indent'>   <a href='https://en.wikipedia.org/wiki/Quantization_(signal_processing)'>Scalar Quantization</a> (SQ) is the process of decreasing the number of discrete levels
that a signal can take <span class='cite'>[<a href='#Xsayood2017introduction'>5</a>]</span>. <a href='https://en.wikipedia.org/wiki/Vector_quantization'>Vector Quantization</a> (VQ) is similar, but is applied to
tuples of samples at the same time <span class='cite'>[<a href='#Xvetterli2014foundations'>8</a>]</span>. SQ is used when the samples are decorrelated
or althought are correlated, the decorrelation will be exploited in a <a href='https://en.wikipedia.org/wiki/Entropy_encoding'>entropy coding</a>
stage (which in our case is DEFLATE), because the <a href='https://en.wikipedia.org/wiki/Quantization_(signal_processing)#Rate%E2%80%93distortion_optimization'>coding efficiency</a> provided by VQ
is marginal in this context <span class='cite'>[<a href='#Xvetterli2014foundations'>8</a>]</span>, and requires in general higher computational
resources.
</p><!-- l. 175 --><p class='indent'>   Quantizers can also be classified into <a href='https://en.wikipedia.org/wiki/Quantization_(signal_processing)#Mid-riser_and_mid-tread_uniform_quantizers'>uniform</a> and <a href='https://nptel.ac.in/content/storage2/courses/117104069/chapter_5/5_5.html'>non-uniform</a> <span class='cite'>[<a href='#Xsayood2017introduction'>5</a>, <a href='#Xvetterli2014foundations'>8</a>]</span>. An uniform
quantizer distributes the available representation levels uniformely over the range of input
values. Non-uniform quantizers use higher density of representation levels (more output
levels per input different values) to those intervals of input values that occur more
often.<span class='footnote-mark'><a href='#fn5x0' id='fn5x0-bk'><sup class='textsuperscript'>5</sup></a></span><a id='x1-5001f5'></a>
Non-uniform quantizers can also be classified into static and <a href='https://en.wikipedia.org/wiki/Adaptive_differential_pulse-code_modulation'>adaptive quantizers</a>. In
the first case, the <a href='https://en.wikipedia.org/wiki/Probability_distribution'>distribution</a> of the representation levels remains constant during
the quantization stage, and in the second case, the quantizer parameters are adapted
dinamically to the characteristics of the input signal. In this milestone we will use an
                                                                  

                                                                  
<a href='https://en.wikipedia.org/wiki/Quantization_(signal_processing)#Dead-zone_quantizers'>uniform dead-zone scalar static quantizer</a>, which can be implemented efficiently (in
software) for digital signals. Moreover, dead-zone quantizers tend to produce more
quantization indices equal to 0 (which increases compression rates) at the cost of
generating more quantization noise for values of the input signal close to 0,
or what is the same, decreasing the <a href='https://en.wikipedia.org/wiki/Signal-to-noise_ratio'>SNR</a> for small signal values. A priori,
this could be seen as a problem, but in reality it is not because precisely
when the amplitude of the signal is small and the noise is independent of its
amplitude (which usually happens with <a href='https://en.wikipedia.org/wiki/Noise_(electronics)'>electronic noise</a>), the SNR of the input
signal has its lowest value precisely for those values close to 0. Therefore, the
quantizer basically is going to change the electronic noise by quantization
noise<span class='footnote-mark'><a href='#fn6x0' id='fn6x0-bk'><sup class='textsuperscript'>6</sup></a></span><a id='x1-5002f6'></a>
(see this <a href='https://github.com/vicente-gonzalez-ruiz/signal_quantization'>introduction to signal quantization</a> and this <a href='https://github.com/vicente-gonzalez-ruiz/scalar_quantization'>comparative between digital
scalar quantizers</a>). Finally, although this is a feature that we are not going to exploit
for now, dead-zone quantizers extracts bit-planes when the quantization steps sizes
are powers of two, allowing the design of progressive entropy encoding schemes, if
required.
</p><!-- l. 223 --><p class='noindent'>
</p>
   <h4 class='subsectionHead' id='bit-rate-control-and-distortion'><span class='titlemark'>1.4   </span> <a id='x1-60001.4'></a>(Bit-) Rate control and distortion</h4>
<!-- l. 225 --><p class='noindent'>The number of representation levels used by a quantizer depends basically on the
quantization step (size), typically denoted by \(\Delta \). The higher the \(\Delta \), the smaller the
number of representation levels, and therefore, the higher the distortion generated by
the quantization error (see the previous notebooks), and the smaller the output
bit-rate. This generates a <a href='https://en.wikipedia.org/wiki/Rate%E2%80%93distortion_theory'>rate/distortion</a> trade-off that is descriptive of all lossy
compressors.
</p><!-- l. 234 --><p class='indent'>   The control of the bit-rate through the \(\Delta \) values is a technique that can be used in
real-time transmission systems to minimize the jitter and the loss of packets when
<a href='https://en.wikipedia.org/wiki/Network_congestion'>congestion</a> occurs. However, notice that depending of the <a href='https://en.wikipedia.org/wiki/Entropy_(information_theory)'>entropy</a> coding stage
and the characteristics of the signal (<a href='https://en.wikipedia.org/wiki/Variance'>variance</a>, entropy) may not exist a
clear relationship between the \(\Delta \) and the output bit-rate. This happens using
DEFLATE.
</p><!-- l. 245 --><p class='indent'>   Notice also that any rate-control algorithm based on quantization has a
characteristic RD (Rate/Distortion) curve, in which the X axis represents the (in the
case of InterCom, received) bit-rate and the Y axis the distortion in the
reconstruction (in the case of InterCom, the played audio sequence) obtained after
the quantization. Some examples can be found in <a href='https://github.com/Tecnologias-multimedia/Tecnologias-multimedia.github.io/blob/master/study_guide/BR_control/audio_quantization.ipynb'>this notebook</a>.
</p><!-- l. 255 --><p class='noindent'>
</p>
   <h4 class='subsectionHead' id='the-current-implementations-for-the-control-of-the-bitrate'><span class='titlemark'>1.5   </span> <a id='x1-70001.5'></a>The current implementation(s) for the control of the bit-rate</h4>
<!-- l. 257 --><p class='noindent'>Bit-Rate (BR) control through quantization has been implemented in the class
<span class='obeylines-h'><span class='verb'><span class='ectt-1000'>BR_Control*</span></span></span> of the modules <span class='ectt-1000'>BR_control*.py</span>. This class overrides the inherited
                                                                  

                                                                  
methods <span class='obeylines-h'><span class='verb'><span class='ectt-1000'>pack()</span></span></span> and <span class='obeylines-h'><span class='verb'><span class='ectt-1000'>unpack()</span></span></span>, performing now:
</p>
   <!-- l. 262 -->
   <pre class='lstlisting' id='listing-1'><span class='label'><a id='x1-7001r1'></a></span><span class='ectt-1000'>  </span><span style='color:#000000'><span class='ectt-1000'>def</span></span><span style='color:#000000'> <span class='ectt-1000'>pack(chunk_number, </span><span class='ectt-1000'>chunk):</span> 
</span><span class='label'><a id='x1-7002r2'></a></span><span class='ectt-1000'>   </span><span style='color:#000000'><span class='ectt-1000'>quantized_chunk</span></span><span style='color:#000000'> <span class='ectt-1000'>= </span><span class='ectt-1000'>quantize(chunk)</span> </span><span class='ecit-1000'> </span><span style='color:#000000'><span class='ecit-1000'>#</span></span><span style='color:#000000'> <span class='ecit-1000'>(1)</span> 
</span><span class='label'><a id='x1-7003r3'></a></span><span class='ectt-1000'>   </span><span style='color:#000000'><span class='ectt-1000'>packed_chunk</span></span><span style='color:#000000'> <span class='ectt-1000'>= </span><span class='ectt-1000'>Buffering.pack(chunk_number, </span><span class='ectt-1000'>quantized_chunk)</span> </span><span class='ecit-1000'> </span><span style='color:#000000'><span class='ecit-1000'>#</span></span><span style='color:#000000'> <span class='ecit-1000'>(2)</span> 
</span><span class='label'><a id='x1-7004r4'></a></span><span class='ectt-1000'>   </span><span style='color:#000000'><span class='ectt-1000'>return</span></span><span style='color:#000000'> <span class='ectt-1000'>packed_chunk</span> </span><span class='ecit-1000'> </span><span style='color:#000000'><span class='ecit-1000'>#</span></span><span style='color:#000000'> <span class='ecit-1000'>(3)</span></span></pre>
   
   <!-- l. 269 -->
   <pre class='lstlisting' id='listing-2'><span class='label'><a id='x1-7005r1'></a></span><span class='ectt-1000'>  </span><span style='color:#000000'><span class='ectt-1000'>def</span></span><span style='color:#000000'> <span class='ectt-1000'>unpack(packed_chunk):</span> 
</span><span class='label'><a id='x1-7006r2'></a></span><span class='ectt-1000'>   </span><span style='color:#000000'><span class='ectt-1000'>(</span></span><span style='color:#000000'><span class='ectt-1000'>chunk_number</span></span><span style='color:#000000'><span class='ectt-1000'>,</span></span><span style='color:#000000'> <span class='ectt-1000'>quantized_chunk) </span><span class='ectt-1000'>= </span><span class='ectt-1000'>Buffering.unpack(packed_chunk)</span> </span><span class='ecit-1000'> </span><span style='color:#000000'><span class='ecit-1000'>#</span></span><span style='color:#000000'> <span class='ecit-1000'>(1)</span> 
</span><span class='label'><a id='x1-7007r3'></a></span><span class='ectt-1000'>   </span><span style='color:#000000'><span class='ectt-1000'>chunk</span></span><span style='color:#000000'> <span class='ectt-1000'>= </span><span class='ectt-1000'>dequantize(quantized_chunk)</span> </span><span class='ecit-1000'> </span><span style='color:#000000'><span class='ecit-1000'>#</span></span><span style='color:#000000'> <span class='ecit-1000'>(2)</span> 
</span><span class='label'><a id='x1-7008r4'></a></span><span class='ectt-1000'>   </span><span style='color:#000000'><span class='ectt-1000'>return</span></span><span style='color:#000000'> <span class='ectt-1000'>(chunk_number, </span><span class='ectt-1000'>chunk)</span> </span><span class='ecit-1000'> </span><span style='color:#000000'><span class='ecit-1000'>#</span></span><span style='color:#000000'> <span class='ecit-1000'>(3)</span></span></pre>
   
<!-- l. 276 --><p class='indent'>   Notice that, regarding the bit-rate control, you will find four implementations
related to this milestone:
     </p><ol class='enumerate1'>
<li class='enumerate' id='x1-7010x1'><span class='obeylines-h'><span class='verb'><span class='ectt-1000'>BR_control_no.py</span></span></span>: Uses a constant \(\Delta &gt;0\).<span class='footnote-mark'><a href='#fn7x0' id='fn7x0-bk'><sup class='textsuperscript'>7</sup></a></span><a id='x1-7011f7'></a>
     There is not BR control.
     </li>
<li class='enumerate' id='x1-7013x2'><span class='obeylines-h'><span class='verb'><span class='ectt-1000'>BR_control_add_lost.py</span></span></span>: Every second runs: \begin {equation}  \Delta = \Delta + L - 1  \end {equation}
     where \(L\) is the number of lost (received) chunks in the previous second. Notice
     that this heuristic (and the following ones) supposes that the interlocutor is
     lossing (on average) the same number of chunks.
     </li>
<li class='enumerate' id='x1-7015x3'><span class='obeylines-h'><span class='verb'><span class='ectt-1000'>BR_control_lost.py</span></span></span>: Every second runs: \begin {equation}  \Delta = L - 1.  \end {equation}
     </li>
<li class='enumerate' id='x1-7017x4'><span class='obeylines-h'><span class='verb'><span class='ectt-1000'>BR_control_conservative.py</span></span></span>: Every second runs: \begin {equation}  \left \{ \begin {array}{ll} \Delta = 2\Delta &amp; \quad \text {if}~L&gt;1 \\ \Delta = \frac {1}{2}\Delta &amp; \quad \text {otherwise}. \end {array} \right .  \end {equation}
     </li></ol>
<!-- l. 309 --><p class='noindent'>
</p>
   <h3 class='sectionHead' id='what-do-you-have-to-do'><span class='titlemark'>2   </span> <a id='x1-80002'></a>What do you have to do?</h3>
                                                                  

                                                                  
<!-- l. 311 --><p class='noindent'>
</p>
   <h4 class='subsectionHead' id='estimate-the-bitrate-in-an-internet-link'><span class='titlemark'>2.1   </span> <a id='x1-90002.1'></a>Estimate the bit-rate in an Internet link</h4>
<!-- l. 313 --><p class='noindent'>Usually, we need to use a tool such as <a href='https://iperf.fr/'>iPerf</a> to <a href='https://en.wikipedia.org/wiki/Measuring_network_throughput'>measure the link capacity</a> between two
<a href='https://datatracker.ietf.org/doc/html/rfc4113'>end-points</a> (of different <a href='https://en.wikipedia.org/wiki/Host_(network)'>hosts</a>) in the Internet. This proceduce implies that we must
have access to both hosts to install and run this program, privileges that are not
always available.
</p><!-- l. 324 --><p class='indent'>   Alternatively, we can estimate the <a href='https://en.wikipedia.org/wiki/Throughput'>link throughput</a> using <a href='https://github.com/torvalds/linux/blob/master/net/ipv4/ping.c'><span class='ectt-1000'>ping</span></a> (see the <a href='https://tecnologias-multimedia.github.io/study_guide/latency/'>previous
milestone</a>). At this point is important to realize that <span class='ectt-1000'>ping </span>has been designed to
measure latencies, not bit-rates, and that for this reason, we will be able only to
estimate throughputs, rougtly.
</p><!-- l. 334 --><p class='indent'>   The transmission bitrate available between two directly reachable IP devices can
be estimated as \begin {equation}  b=\frac {B}{t_t}, \label {eq:b}  \end {equation}
where \(B\) is the number of bits sent in a <span class='obeylines-h'><span class='verb'><span class='ectt-1000'>ping</span></span></span> <a href='https://en.wikipedia.org/wiki/Payload_(computing)'>payload</a>, and \begin {equation}  t_t = \frac {\text {RTT}_{\text {max}}-2t_p}{2}, \label {eq:tt}  \end {equation}
an equation that can be determined by revisiting the <span class='obeylines-h'><span class='verb'><span class='ectt-1000'>ping</span></span></span> timeline (Fig. 1) and the
Eq. 2 of the <a href='https://tecnologias-multimedia.github.io/study_guide/latency/'>previous milestone</a>.
</p><!-- l. 351 --><p class='indent'>   Notice that if the payload of the ping is small enough (\(0\) bytes ideally, and
therefore \(t_t=0\)), we can consider that \begin {equation}  t_p \approx \frac {\text {RTT}_{\text {min}}}{2}, \label {eq:tp}  \end {equation}
and that for measuring the \(\text {RTT}\) in Eq. \eqref{eq:tt}, we should use a payload as large as
possible (ideally, a infinite number of bytes), in order to make \(t_t\) a significative amount
of time, ease to measure. Notice also that we should use the smallest RTT value of a
<span class='ectt-1000'>ping </span>session of measurements in the Eq. \eqref{eq:tp} because the minimum
link latency is a constant and the congestion of the link always increases
it.
</p><!-- l. 365 --><p class='indent'>   Therefore, supposing that \(t_p\) is constant and using the
average<span class='footnote-mark'><a href='#fn8x0' id='fn8x0-bk'><sup class='textsuperscript'>8</sup></a></span><a id='x1-9001f8'></a> \(\text {RTT}\)
for transmitting \(B\) bits (\(B\) as large as possible), the bit-rate value \(b\) determined by
Eq. \eqref{eq:b} can be considered as a good estimation for the link of the near
future.
</p><!-- l. 372 --><p class='indent'>   So, for determining \(b\) we must run the following steps:
     </p><ol class='enumerate1'>
<li class='enumerate' id='x1-9003x1'>Run <span class='ectt-1000'>ping </span>using the smallest possible payload that provides RTTs values.<span class='footnote-mark'><a href='#fn9x0' id='fn9x0-bk'><sup class='textsuperscript'>9</sup></a></span><a id='x1-9004f9'></a>
     Use it for computing \(t_p\).
     </li>
<li class='enumerate' id='x1-9006x2'>Run <span class='ectt-1000'>ping </span>using the largest possible payload to achieve that the most part
     of the average RTT provided by <span class='ectt-1000'>ping </span>corresponds to \(t_t\). It is necessary to
     use the highest payload-size because the accuracy of the cronometer used
     by <span class='ectt-1000'>ping</span>, in general, is not high enough.
     </li>
                                                                  

                                                                  
<li class='enumerate' id='x1-9008x3'>Use Eq. \eqref{eq:tt} to find \(t_t\) as a function of the average RTT and the
     minimal \(t_p\).
     </li>
<li class='enumerate' id='x1-9010x4'>Finally, use Eq. \eqref{eq:b} to determine \(b\).</li></ol>
<!-- l. 392 --><p class='indent'>   If the devices cannot be <span class='ectt-1000'>ping</span>-ed, and supposing that there is only one point in
the communication link that is filtering the ICMP Echo Request traffic in each
direction, then we can apply the same technique that was used in the <a href='https://tecnologias-multimedia.github.io/study_guide/latency/'>previous
milestone</a>, which basically consists in computing the total RTT as the sum of the
RTTs from the devices that we want to connect (where the InterCom is it supposed
to be run) to the filter (possiblely, one of your home routers). A similar throughput
estimation should be obtained considering only the slower part of the total
link.
</p><!-- l. 403 --><p class='indent'>   (Optional) In order to gain experience with all this stuff, measure your bandwith
(using your local host) with different <span class='ectt-1000'>ping </span>servers, try to compute the link
throughput:
     </p><ol class='enumerate1'>
<li class='enumerate' id='x1-9012x1'>In <a href='https://en.wikipedia.org/wiki/Localhost'><span class='ectt-1000'>localhost</span></a>.
     </li>
<li class='enumerate' id='x1-9014x2'>In <span class='ectt-1000'>localhost</span>, limiting the bit-rate with <span class='ectt-1000'>tc</span>.
     </li>
<li class='enumerate' id='x1-9016x3'>Between two hosts in your <a href='https://en.wikipedia.org/wiki/Local_area_network'>local network</a> (your host and your router, for
     example). Notice that in this case, you should not obtain a bit-rate higher
     than the capacity of your <a href='https://en.wikipedia.org/wiki/Network_interface_controller'>network adapter</a>.
     </li>
<li class='enumerate' id='x1-9018x4'>Between your host and a public host of the Internet. Try <a href='https://www.meter.net/'><span class='ectt-1000'>www.meter.net</span></a>
     for example.</li></ol>
                                                                  

                                                                  
<!-- l. 421 --><p class='noindent'>
</p>
   <h4 class='subsectionHead' id='simulate-the-link'><span class='titlemark'>2.2   </span> <a id='x1-100002.2'></a>Simulate the link</h4>
<!-- l. 423 --><p class='noindent'>With the bit-rate value \(b\) computed from the previous section, simulate such link
(locally) with:
</p>
   <!-- l. 426 -->
<p id='languagebash'><a id='x1-10001'></a>
   </p><pre class='lstlisting' id='listing-3'><span class='label'><a id='x1-10002r1'></a></span><span class='ectt-1000'>  </span><span style='color:#000000'><span class='ectt-1000'>sudo</span></span><span style='color:#000000'> <span class='ectt-1000'>tc </span><span class='ectt-1000'>qdisc </span><span class='ectt-1000'>add </span><span class='ectt-1000'>dev </span><span class='ectt-1000'>lo </span><span class='ectt-1000'>root </span><span class='ectt-1000'>handle </span><span class='ectt-1000'>1: </span><span class='ectt-1000'>tbf </span><span class='ectt-1000'>rate </span><span class='ectt-1000'>&lt;bit-rate_in_kbps&gt;kbit </span><span class='ectt-1000'>burst </span><span class='ectt-1000'>32kbit </span><span class='ectt-1000'>limit </span><span class='ectt-1000'>32kbit</span> 
</span><span class='label'><a id='x1-10003r2'></a></span><span class='ectt-1000'>  </span><span style='color:#000000'><span class='ectt-1000'>sudo</span></span><span style='color:#000000'> <span class='ectt-1000'>tc </span><span class='ectt-1000'>qdisc </span><span class='ectt-1000'>add </span><span class='ectt-1000'>dev </span><span class='ectt-1000'>lo </span><span class='ectt-1000'>root </span><span class='ectt-1000'>parent </span><span class='ectt-1000'>1:1 </span><span class='ectt-1000'>handle </span><span class='ectt-1000'>10: </span><span class='ectt-1000'>netem </span><span class='ectt-1000'>delay </span><span class='ectt-1000'>&lt;average_delay_in_miliseconds&gt;ms </span><span class='ectt-1000'>&lt;maximum_average_deviation_in_miliseconds&gt;ms </span><span class='ectt-1000'>&lt;Pearson_correlation_coefficient_expressed_as_a_percentage&gt;% </span><span class='ectt-1000'>distribution </span><span class='ectt-1000'>&lt;uniform|normal|pareto|paretonormal&gt;</span></span></pre>
   
<!-- l. 431 --><p class='indent'>   Examples:
</p><!-- l. 433 --><p class='indent'>
     </p><ol class='enumerate1'>
<li class='enumerate' id='x1-10005x1'>
     <!-- l. 434 --><p class='noindent'>Check the current configuration:
</p>
     <!-- l. 436 -->
     <pre class='lstlisting' id='listing-4'><span class='label'><a id='x1-10006r3'></a></span><span class='ectt-1000'>   </span><span style='color:#000000'><span class='ectt-1000'>tc</span></span><span style='color:#000000'> <span class='ectt-1000'>qdisc </span><span class='ectt-1000'>show </span><span class='ectt-1000'>dev </span><span class='ectt-1000'>lo</span></span></pre>
     
     <!-- l. 440 --><p class='noindent'>The output should be something like:
</p>
     <!-- l. 442 -->
     <pre class='lstlisting' id='listing-5'><span class='label'><a id='x1-10007r4'></a></span><span class='ectt-1000'>   </span><span style='color:#000000'><span class='ectt-1000'>qdisc</span></span><span style='color:#000000'> <span class='ectt-1000'>noqueue </span><span class='ectt-1000'>0: </span><span class='ectt-1000'>root </span><span class='ectt-1000'>refcnt </span><span class='ectt-1000'>2</span></span></pre>
     
     </li>
<li class='enumerate' id='x1-10009x2'>
     <!-- l. 446 --><p class='noindent'>Define the rule for the bit-rate control (example for \(200\) kbps):
</p>
     <!-- l. 448 -->
     <pre class='lstlisting' id='listing-6'><span class='label'><a id='x1-10010r5'></a></span><span class='ectt-1000'>   </span><span style='color:#000000'><span class='ectt-1000'>sudo</span></span><span style='color:#000000'> <span class='ectt-1000'>tc </span><span class='ectt-1000'>qdisc </span><span class='ectt-1000'>add </span><span class='ectt-1000'>dev </span><span class='ectt-1000'>lo </span><span class='ectt-1000'>root </span><span class='ectt-1000'>handle </span><span class='ectt-1000'>1: </span><span class='ectt-1000'>tbf </span><span class='ectt-1000'>rate </span><span class='ectt-1000'>200kbit </span><span class='ectt-1000'>burst </span><span class='ectt-1000'>32kbit </span><span class='ectt-1000'>limit </span><span class='ectt-1000'>32kbit</span></span></pre>
     
     </li>
<li class='enumerate' id='x1-10012x3'>
     <!-- l. 452 --><p class='noindent'>Define the rule for the latency control (example for \(100\) ms, \(10\) ms of jitter, and <a href='https://wiki.linuxfoundation.org/networking/netem'>with
     the next random transmission depending \(25\)% on the last one</a>):
                                                                  

                                                                  
</p>
     <!-- l. 457 -->
     <pre class='lstlisting' id='listing-7'><span class='label'><a id='x1-10013r6'></a></span><span class='ectt-1000'>   </span><span style='color:#000000'><span class='ectt-1000'>sudo</span></span><span style='color:#000000'> <span class='ectt-1000'>tc </span><span class='ectt-1000'>qdisc </span><span class='ectt-1000'>add </span><span class='ectt-1000'>dev </span><span class='ectt-1000'>lo </span><span class='ectt-1000'>parent </span><span class='ectt-1000'>1:1 </span><span class='ectt-1000'>handle </span><span class='ectt-1000'>10: </span><span class='ectt-1000'>netem </span><span class='ectt-1000'>delay </span><span class='ectt-1000'>100ms </span><span class='ectt-1000'>10ms </span><span class='ectt-1000'>25% </span><span class='ectt-1000'>distribution </span><span class='ectt-1000'>normal</span></span></pre>
     
     </li>
<li class='enumerate' id='x1-10015x4'>
     <!-- l. 461 --><p class='noindent'>After adding these rules, this should be the configuration:
</p>
     <!-- l. 463 -->
     <pre class='lstlisting' id='listing-8'><span class='label'><a id='x1-10016r7'></a></span><span class='ectt-1000'>   </span><span style='color:#000000'><span class='ectt-1000'>tc</span></span><span style='color:#000000'> <span class='ectt-1000'>qdisc </span><span class='ectt-1000'>show </span><span class='ectt-1000'>dev </span><span class='ectt-1000'>lo</span></span></pre>
     
     <!-- l. 467 --><p class='noindent'>The output should be something like:
</p>
     <!-- l. 469 -->
     <pre class='lstlisting' id='listing-9'><span class='label'><a id='x1-10017r8'></a></span><span class='ectt-1000'>   </span><span style='color:#000000'><span class='ectt-1000'>qdisc</span></span><span style='color:#000000'> <span class='ectt-1000'>tbf </span><span class='ectt-1000'>1: </span><span class='ectt-1000'>root </span><span class='ectt-1000'>refcnt </span><span class='ectt-1000'>2 </span><span class='ectt-1000'>rate </span><span class='ectt-1000'>200Kbit </span><span class='ectt-1000'>burst </span><span class='ectt-1000'>4Kb </span><span class='ectt-1000'>lat </span><span class='ectt-1000'>0us</span> 
</span><span class='label'><a id='x1-10018r9'></a></span><span class='ectt-1000'>   </span><span style='color:#000000'><span class='ectt-1000'>qdisc</span></span><span style='color:#000000'> <span class='ectt-1000'>netem </span><span class='ectt-1000'>10: </span><span class='ectt-1000'>parent </span><span class='ectt-1000'>1:1 </span><span class='ectt-1000'>limit </span><span class='ectt-1000'>1000 </span><span class='ectt-1000'>delay </span><span class='ectt-1000'>100ms</span> </span><span class='ectt-1000'> </span><span style='color:#000000'><span class='ectt-1000'>10</span></span><span style='color:#000000'><span class='ectt-1000'>ms</span></span><span style='color:#000000'> <span class='ectt-1000'>25%</span></span></pre>
     
     </li></ol>
<!-- l. 476 --><p class='indent'>   Remember to delete the rules after their are unnecessary (example to delete the
previous rules):
</p>
   <!-- l. 478 -->
   <pre class='lstlisting' id='listing-10'><span class='label'><a id='x1-10019r10'></a></span><span class='ectt-1000'>  </span><span style='color:#000000'><span class='ectt-1000'>sudo</span></span><span style='color:#000000'> <span class='ectt-1000'>tc </span><span class='ectt-1000'>qdisc </span><span class='ectt-1000'>delete </span><span class='ectt-1000'>dev </span><span class='ectt-1000'>lo </span><span class='ectt-1000'>parent </span><span class='ectt-1000'>1:1 </span><span class='ectt-1000'>handle </span><span class='ectt-1000'>10: </span><span class='ectt-1000'>netem </span><span class='ectt-1000'>delay </span><span class='ectt-1000'>100ms </span><span class='ectt-1000'>10ms </span><span class='ectt-1000'>25% </span><span class='ectt-1000'>distribution </span><span class='ectt-1000'>normal</span> 
</span><span class='label'><a id='x1-10020r11'></a></span><span class='ectt-1000'>  </span><span style='color:#000000'><span class='ectt-1000'>sudo</span></span><span style='color:#000000'> <span class='ectt-1000'>tc </span><span class='ectt-1000'>qdisc </span><span class='ectt-1000'>delete </span><span class='ectt-1000'>dev </span><span class='ectt-1000'>lo </span><span class='ectt-1000'>root </span><span class='ectt-1000'>handle </span><span class='ectt-1000'>1: </span><span class='ectt-1000'>tbf </span><span class='ectt-1000'>rate </span><span class='ectt-1000'>200kbit </span><span class='ectt-1000'>burst </span><span class='ectt-1000'>32kbit </span><span class='ectt-1000'>limit </span><span class='ectt-1000'>32kbit</span></span></pre>
   
<!-- l. 484 --><p class='noindent'>
</p>
   <h4 class='subsectionHead' id='which-dataordering-performs-better'><span class='titlemark'>2.3   </span> <a id='x1-110002.3'></a>Which data-ordering performs better?</h4>
<!-- l. 486 --><p class='noindent'>Determine empirically which ordering of the chunk data is the most efficient from a
lossless data compression point of view (the smaller the bit-rates, the higher the
compression). Use the audio sequence you want. Some samples are stored in the <span class='obeylines-h'><span class='verb'><span class='ectt-1000'>data</span></span></span>
directory of intercom.
                                                                  

                                                                  
</p><!-- l. 493 --><p class='noindent'>
</p>
   <h4 class='subsectionHead' id='compute-rd-ratedistortion-curves'><span class='titlemark'>2.4   </span> <a id='x1-120002.4'></a>Compute RD (Rate/Distortion) curves</h4>
<!-- l. 495 --><p class='noindent'>Considering the <a href='https://en.wikipedia.org/wiki/Root-mean-square_deviation'>RMSE (Root Mean Square Error)</a> as distortion measure between the
sent and the received audio signal (using only one instance of InterCom), generate
the RD curve considering a set of different simulated transmission environments (use
<a href='https://man7.org/linux/man-pages/man8/tc.8.html'>tc</a>) of one audio sequence (remember that you can use one of the samples found in
the <span class='obeylines-h'><span class='verb'><span class='ectt-1000'>data</span></span></span> directory of the InterCom’s repo), for the four implementations. Notice that
you can use the <span class='obeylines-h'><span class='verb'><span class='ectt-1000'>--minimal_quantization_step</span></span></span> parameter to generate the different
points of the RD curves.
</p><!-- l. 511 --><p class='noindent'>
</p>
   <h3 class='sectionHead' id='deliverables'><span class='titlemark'>3   </span> <a id='x1-130003'></a>Deliverables</h3>
<!-- l. 513 --><p class='noindent'>A report documenting the experiments and the results.
</p><!-- l. 515 --><p class='noindent'>
</p>
   <h3 class='sectionHead' id='resources'><span class='titlemark'>4   </span> <a id='x1-140004'></a>Resources</h3>
   <div class='thebibliography'>
   <p class='bibitem'><span class='biblabel'>
 [1]<span class='bibsp'>   </span></span><a id='Xbosi2003intro'></a>M. Bosi and R.E. Goldberd.  <a href='https://last.hit.bme.hu/download/vidtechlab/fcc/literature/audio/audio_coding_standards_book.pdf'><span class='ecti-1000'>Introduction to Digital Audio Coding and
   </span><span class='ecti-1000'>Standards</span></a>. Kluwer Academic Publishers, 2003.
   </p>
   <p class='bibitem'><span class='biblabel'>
 [2]<span class='bibsp'>   </span></span><a id='XForouzan'></a>Behrouz   Forouzan.      <a href='https://github.com/aboelkassem/References_Books/blob/master/Data%20Communications%20and%20Networking%20By%20Behrouz%20A.Forouzan.pdf'><span class='ecti-1000'>Introduction  to  Data  Communications  and
   </span><span class='ecti-1000'>Networking</span></a>. McGraw-Hill, 2007.
   </p>
   <p class='bibitem'><span class='biblabel'>
 [3]<span class='bibsp'>   </span></span><a id='Xbert2012lartc'></a>Bert Hubert, Thomas Graf, Greg Maxwell, Remco van Mook, Martijn
   van Oosterhout, Paul B. Schroeder, Jasper Spaans, and Pedro Larroy. <a href='https://lartc.org/'><span class='ecti-1000'>Linux
   </span><span class='ecti-1000'>Advanced Routing &amp; Traffic Control</span></a>. Publisher: Bert Humbert et al., 2012.
   </p>
   <p class='bibitem'><span class='biblabel'>
 [4]<span class='bibsp'>   </span></span><a id='Xnelson96datacompression'></a>Nelson M. and Gailly J.  <a href='https://theswissbay.ch/pdf/Gentoomen%20Library/Information%20Theory/Compression/The%20Data%20Compression%20Book%202nd%20Ed%20-%20Mark%20Nelson.pdf'><span class='ecti-1000'>The Data Compression Book</span></a>.  M&amp;T Books,
   1996.
                                                                  

                                                                  
   </p>
   <p class='bibitem'><span class='biblabel'>
 [5]<span class='bibsp'>   </span></span><a id='Xsayood2017introduction'></a>K. Sayood.    <a href='http://rahilshaikh.weebly.com/uploads/1/1/6/3/11635894/data_compression.pdf'><span class='ecti-1000'>Introduction  to  Data  Compression</span></a>  <a href='https://people.cs.nctu.edu.tw/~cmliu/Courses/Compression/'><span class='ecti-1000'>(Slides)</span></a>.    Morgan
   Kaufmann, 2017.
   </p>
   <p class='bibitem'><span class='biblabel'>
 [6]<span class='bibsp'>   </span></span><a id='XTanenbaum'></a>Andrew S. Tanenbaum. <a href='https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwj9857DgLvsAhUTA2MBHTJfCZ4QFjAAegQIBBAC&amp;url=https%3A%2F%2Fdocs.google.com%2Fviewer%3Fa%3Dv%26pid%3Dsites%26srcid%3DZGVmYXVsdGRvbWFpbnxza21pbmh8Z3g6NjQxMTI2MmYxMTAwZmNjZQ&amp;usg=AOvVaw3m5WEH7H2923_hOFl1e-W-'><span class='ecti-1000'>Computer Networks</span></a>. Prentice Hall, 2011.
   </p>
   <p class='bibitem'><span class='biblabel'>
 [7]<span class='bibsp'>   </span></span><a id='Xtaubman2002jpeg2000'></a>D.S. Taubman and W.M. Marcellin.   <a href='https://last.hit.bme.hu/download/firtha/video/JPEG2000/David%20S.%20Taubman,%20%20Michael%20W.%20Marcellin%20%20(auth.)%20JPEG2000%20Image%20Compression%20Fundamentals,%20Standards%20and%20Practice%20%202002.pdf'><span class='ecti-1000'>JPEG2000. Image Compression
   </span><span class='ecti-1000'>Fundamentals, Standards and Practice</span></a>. Kluwer Academic Publishers, 2002.
   </p>
   <p class='bibitem'><span class='biblabel'>
 [8]<span class='bibsp'>   </span></span><a id='Xvetterli2014foundations'></a>M. Vetterli, J. Kovačević, and V.K. Goyal.  <a href='http://www.fourierandwavelets.org/FSP_v1.1_2014.pdf'><span class='ecti-1000'>Foundations of Signal
   </span><span class='ecti-1000'>Processing</span></a>. Cambridge University Press, 2014.
</p>
   </div>
<p id='references'><a id='Q1-1-17'></a>
   </p><div class='footnotes'><!-- l. 22 --><p class='indent'>     <span class='footnote-mark'><a href='#fn1x0-bk' id='fn1x0'><sup class='textsuperscript'>1</sup></a></span><span class='ecrm-0800'>Measured in bits per second or a</span> \(10\)<span class='ecrm-0800'>-multiple of this transmission </span><a href='https://en.wikipedia.org/wiki/Bandwidth_(computing)'><span class='ecrm-0800'>capacity</span></a><span class='ecrm-0800'>.</span></p>
<!-- l. 41 --><p class='indent'>     <span class='footnote-mark'><a href='#fn2x0-bk' id='fn2x0'><sup class='textsuperscript'>2</sup></a></span><span class='ecrm-0800'>Follow the same rubric than in the case of the measurement of the impact of the
</span><span class='ecrm-0800'>latency.</span></p>
<!-- l. 54 --><p class='indent'>     <span class='footnote-mark'><a href='#fn3x0-bk' id='fn3x0'><sup class='textsuperscript'>3</sup></a></span><span class='ecrm-0800'>Notice that, in this case, we would be at least contributing, if not causing, the link
</span><span class='ecrm-0800'>congestion.</span></p>
<!-- l. 123 --><p class='noindent'><span class='footnote-mark'><a href='#fn4x0-bk' id='fn4x0'><sup class='textsuperscript'>4</sup></a></span><span class='ecrm-0800'>Used in a future improvements of intercom.</span></p>
<!-- l. 185 --><p class='indent'>     <span class='footnote-mark'><a href='#fn5x0-bk' id='fn5x0'><sup class='textsuperscript'>5</sup></a></span><span class='ecrm-0800'>The decision intervals and the representation levels in each interval can be also optimized
</span><span class='ecrm-0800'>using other criteria, such as, minimizing the rate/distortion at a given point of the RD
</span><span class='ecrm-0800'>curve.</span></p><!-- l. 210 --><p class='indent'> <span class='footnote-mark'><a href='#fn6x0-bk' id='fn6x0'><sup class='textsuperscript'>6</sup></a></span><span class='ecrm-0800'>The error generated by the quantization stage.</span></p>
<!-- l. 281 --><p class='noindent'><span class='footnote-mark'><a href='#fn7x0-bk' id='fn7x0'><sup class='textsuperscript'>7</sup></a></span>\(\Delta \) <span class='ecrm-0800'>must be always bigger than</span> \(0\)<span class='ecrm-0800'>, by definition, and this does not depend on the bit-rate
</span><span class='ecrm-0800'>control.</span></p><!-- l. 367 --><p class='indent'> <span class='footnote-mark'><a href='#fn8x0-bk' id='fn8x0'><sup class='textsuperscript'>8</sup></a></span><span class='ecrm-0800'>Remember that with the </span><span class='ectt-0800'>ping </span><span class='ecrm-0800'>command we iterate several times and the tool returns
</span><span class='ecrm-0800'>average values.</span></p>
<!-- l. 378 --><p class='noindent'><span class='footnote-mark'><a href='#fn9x0-bk' id='fn9x0'><sup class='textsuperscript'>9</sup></a></span><span class='ecrm-0800'>The minimal payload for a </span><span class='ectt-0800'>ping </span><span class='ecrm-0800'>message can be 0, but depending on the implementation
</span><span class='ecrm-0800'>of </span><span class='ectt-0800'>ping </span><span class='ecrm-0800'>you may be forzed to use a larger value.</span></p>                                                           </div>
 
</body> 
</html>