\input{../definitions}
\title{\TM{} - Study Guide - Milestone 12: Temporal Coding (without chunks overlapping)}

\maketitle

\section{Description}

  
\section{What you have to do?}


% \begin{enumerate}
% \item In a module named temporal\_coding.py, inherit the class
%   Stereo\_Coding defined in stereo\_coding.py, and create
%   a class named Temporal\_Coding.
% \item Select a suitable\footnote{Take into consideration the subband
%     gains and the shape of the wavelet functions in your wavelet
%     selection.} DWT
%     from \href{https://pywavelets.readthedocs.io/en/latest/}{PyWavelets}
%     and transform the MST subbands. Obviously, implement also the
%     inverse stuff for recovering the audio signal.
% \item Compare the RD (Rate/Distortion) curves generated by the modules
%   br\_control.py (that only provides quantization in the original
%   audio domain), stereo\_decorrelate.py (that apply quantization on
%   the transformed frames, that form two subbands $M$ (mid) and $S$
%   (side)) and temporal\_decorrelate.py (that apply quantization on the
%   DWT of the $M$ and $S$ subbands). Notice that the number of levels
%   $N_{\text{levels}}$ of the DWT can have a large impact on the amount
%   of energy concentration achieved by the DWT, and therefore, on the
%   efficiency of coding system.
% \item In the previous compative, we have applied first the temporal
%   decorrelation and after this, the spatial decorrelation. Try also
%   the alternative: remove first the spatial decorrelation and then,
%   the temporal decorrelation. Repeat the RD comparison including this
%   alternartive.
% \end{enumerate}


\section{Timming}

Please, present your results in one week.

\section{Deliverables}

A report showing your results.

\section{Resources}

\bibliography{maths,data-compression,DWT,audio-coding}

\begin{comment}

  The Figure~\ref{fig:transform_coding} shows the stages that are
  tipycally involved in a transform-based signal compression system.

\begin{figure}
  \begin{center}
\begin{verbatim}
   s   +---+   w    +---+   k    +---+    c
 ----->| T |------->| Q |------->| E |-----------+
  (s)  +---+  (s)   +---+  (~s)  +---+   (~s)    |
samples   coefficients   indexes      code-words ~
                                                 :
                                                 ~
   ~s  +---+    w   +---+   k    +---+           |
 <-----| t |<-------| q |<-------| D |<----------+
  (~s) +---+  (~s)  +---+  (~s)  +---+
approx.    quantized     indexes
samples   coefficients
\end{verbatim}                
  \end{center}
  \caption{Common data-flow used un Transform Coding. $s$ represents
    the signal to compress, $\tilde{s}$ the lossy version of the
    reconstructed signal, $T$ the (forward) transform (which takes blocks of
    samples) producing blocks of coefficients $w$, $Q$ the scalar
    quantization stage (which takes single coefficients) producing
    quantization indexes $k$, $E$ the entropy encoder (which in our
    case (DEFLATE) works with blocks of coefficients) producing
    code-words $c$, $D$ the entropy decoder, $q$ the decuantization
    stage, and $t$ the inverse (or backward) transform. PCM stands for Puse Code
    Modulation and DEFLATE is the technique used to find a compact
    representation of the quantized coefficients.}
  \label{fig:transform_coding}
\end{figure}
\end{comment}

