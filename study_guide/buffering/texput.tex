\input{../definitions}
\title{\TM - Study Guide - Milestone 6: Buffering for dejitterizing}

\maketitle

\section{Description}

The QoE provided by InterCom is inversely proportional to the network
jitter (see Fig.~\ref{fig:timelines}-a). One solution to this drawback
(Fig.~\ref{fig:timelines}-b) is the use of a
\href{https://en.wikipedia.org/wiki/Random_access}{random access}
\href{https://en.wikipedia.org/wiki/Data_buffer}{buffer} at the
receiver side, where the chunks are stored for a time large enough to
hidden the jitter to the user~\cite{Kurose-Ross}.

\begin{figure}
  \begin{center}
    \myfig{graphics/timelines}{10cm}{1000}
  \end{center}
  \caption{Timelines of two InterCom interactions. On the left, the
    playback is defective because some chunks are lost. On the right,
    the audio rendering is correct because the playback has been
    delayed 2 chunk times (enough for this example).}
  \label{fig:timelines}
\end{figure}

\href{https://en.wikipedia.org/wiki/Jitter#Jitter_buffers}{\emph{Dejitterizing}
  buffers} are typically implemented with a circular buffer structure
(see the Fig.~\ref{fig:circular_buffer}). In an ideal situation (as
the depicted in the figure), the number of pending-to-be-played chunks
available in the buffer is half of the number of cells in the buffer,
and the chunks have arrived on time. In this example, the receiver
(where the chunks are buffered) waits for 3 chunks before to start
playing the chunk number 0.\footnote{Implementation tip: in a system
  where for each recorded chunk a chunk must be also played, a delay
  in the playback can be generated by sending zero-chunks to the DAC
  and then, after the delay, start sending the received chunk of
  audio, in the right order.} Notice that the number of cells in the
buffer $2N$ must be the double of the number of the chunks buffered
during the buffering time $N$, in order to hide a $N$ chunk-time
jitter. Notice also that this technique introduces also a $N$
chunk-time delay in the playback.

\begin{figure}
  \begin{tabular}{ccc}
    \vbox{\myfig{graphics/circular_buffer1}{2cm}{200}} & \vbox{\myfig{graphics/circular_buffer2}{2cm}{200}} & \vbox{\myfig{graphics/circular_buffer3}{2cm}{200}} \\
    (a) & (b) & (c)
  \end{tabular}
  \caption{A circular buffer with 6 cells (space for 6 chunks). Up to
    the half of the buffer is occupied (cells in gray) because the
    buffering time is 3 chunk times and 3 chunks (with chunk number 0,
    1 and 2 in the beginning, subfigure (a)) have been received. The
    first chunk to be played is chunk 0 (subfigure (b)). Then, a new
    chunk (chunk number 3) is received and buffered (subfigure (c)).}
  \label{fig:circular_buffer}
\end{figure}

For this new improved InterCom a parameter with the \emph{buffering
  time} must be provided by the users. This value (typically expressed
in miliseconds) should be large enough to hide the network jitter, but
small enough to minimize the end-to-end (user) latency.

Use the following basic guidelines to implement the \emph{buffered}
version of InterCom:

\begin{enumerate}
\item Extend
  (\href{https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)}{inherit}
  from) the class Minimal to implement a new class
  Buffering.
\item In the payload of the UDP packets a chunk number must be
  included in order to provide to the receiver the information to
  determine where to store the corresponding chunk in the circular
  buffer. Use an unsigned integer of 16 bits for representing the
  chunk numbers.
\item Take into account that the critical part of InterCom is a
  \href{https://en.wikipedia.org/wiki/Task_(computing)}{task} that
  could be called record\_send\_and\_play(), and this should be
  iterated each time a new chunk is available in the
  \href{https://en.wikipedia.org/wiki/Analog-to-digital_converter}{ADC}. More
  precisely:
  \begin{enumerate}
  \item In order to minimize the latency, the recorded chunks must be
    sent to the interlocutor as soon as possible.
  \item The playback of the chunks extracted from the buffer must be
    \href{https://en.wikipedia.org/wiki/Gapless_playback}{\emph{gapless}}
    (without the ocurrence of silences) as long as the chunks have
    been received on time.
  \item As always, the lost chunks should be replaced by zero-chunks
    in the playback.
  \end{enumerate}
\item A receive\_and\_buffer() task can be run now in a different
  execution
  \href{https://en.wikipedia.org/wiki/Thread_(computing)}{thread},
  decoupled from the record\_send\_and\_play() task. But notice that
  using the sounddevice package this can be achived without using the
  \href{https://docs.python.org/3/library/threading.html}{threading}
  nor
  \href{https://docs.python.org/3/library/multiprocessing.html}{multiprocessing}
   packages because the interruption handler (the so called
  \emph{callback}() function) already runs in parallel with the main
  thread.
\end{enumerate}

\begin{pseudocode}{Buffering\_InterCom}{~}
  \PROCEDURE{record\_send\_and\_play}{~}
  \BEGIN
    \text{chunk} \GETS \text{record}()\\
    \text{packed\_chunk} \GETS \text{pack}(\text{chunk})\\
    \text{send}(\text{packed\_chunk})\\
    \text{chunk} \GETS \text{unbuffer\_next\_chunk}()\\
    \text{play}(\text{chunk})
  \END
  \ENDPROCEDURE
  \PROCEDURE{receive\_and\_buffer}{~}
  \BEGIN
    \text{packed\_chunk} \GETS \text{receive}()\\
    \text{chunk\_number}, \text{chunk} \GETS \text{unpack}(\text{packed\_chunk})\\
    \text{buffer}(\text{chunk\_number}, \text{chunk})
  \END
  \ENDPROCEDURE
\end{pseudocode}

\section{Timming}

Please, finish this milestone in two weeks.

\section{Deliverables}

A python module named buffer.py stored in the
\href{https://github.com/Tecnologias-multimedia/intercom}{root
  directory} of the InterCom's repo.

\section{Resources}

\bibliography{networking}
