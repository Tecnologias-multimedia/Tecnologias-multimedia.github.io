\input{../definitions}
\title{\TM - Study Guide - Milestone 6: Buffering for dejitterizing}

\maketitle

\section{Description}

The QoE provided by InterCom is inversely proportional to the network
jitter (see Fig.~\ref{fig:timelines}-a). One solution to this drawback
(Fig.~\ref{fig:timelines}-b) is the use of a random access buffer at
the receiver side, where the chunks are stored for a time large enough
to hidden the jitter to the user.

\begin{figure}
  \begin{center}
    \myfig{graphics/timelines}{10cm}{1000}
  \end{center}
  \caption{Timelines of two InterCom interactions. On the left, the
    playback is defective because some chunks are lost. On the right,
    the audio rendering is correct because the playback has been
    delayed 2 chunk times (enough for this example).}
  \label{fig:timelines}
\end{figure}

\href{https://en.wikipedia.org/wiki/Jitter#Jitter_buffers}{\emph{Dejitterizing}
  buffers} are typically implemented with a circular buffer (see the
Fig.~\ref{fig:circular_buffer}). In an ideal situation (as the
depicted in the previous figure), the number of unplayed chunks
available in the buffer is half of the number of cells, and the chunks
arrive in order. In this example, the receiver (where the chunks are
buffered) waits for 3 chunks before to start playing the chunk number
0.\footnote{Implementation tip: in a system where for each recorded
chunk a chunk must be also played, a delay in the playback can be
generated by sending first zeroed chunks to the DAC and then, after
the delay, start sending the received chunk of audio, in the right
order.} Notice that the number of cells in the buffer $2N$ must be the
double of the number of the chunks buffered during the buffering time
$N$, in order to hide a $N$ chunk-time jitter. Notice also that this
technique introduces also a $N$ chunk-time delay in the playback.

\begin{figure}
  \begin{tabular}{ccc}
    \vbox{\myfig{graphics/circular_buffer1}{2cm}{200}} & \vbox{\myfig{graphics/circular_buffer2}{2cm}{200}} & \vbox{\myfig{graphics/circular_buffer3}{2cm}{200}} \\
    (a) & (b) & (c)
  \end{tabular}
  %\begin{center}
  %  \myfig{graphics/circular_buffer1}{2cm}{200}
  %  \myfig{graphics/circular_buffer2}{2cm}{200}
    %\begin{tabular}{ccc}
    %  \myfig{graphics/circular_buffer1}{2cm}{200} &
    %  \myfig{graphics/circular_buffer2}{2cm}{200} &
    %  \myfig{graphics/circular_buffer3}{2cm}{200}
    %\end{tabular}   
  %\end{center}
  \caption{A circular buffer with 6 cells (space for 6 chunks). Up to
    the half of the buffer is occupied (cells in gray) because the
    buffering time is 3 chunk times and 3 chunks (with chunk number 0,
    1 and 2 in the beginning, subfigure (a)) have been received. The
    first chunk to be played is chunk 0 (subfigure (b)). Then, a new
    chunk (chunk number 3) is received and buffered (subfigure (c)).}
  \label{fig:circular_buffer}
\end{figure}

For this new improved InterCom the parameter \emph{buffering time}
must be provided by the users. This value (typically expressed in
miliseconds) should be large enough to hide the network jitter, but
small enough to minimize the end-to-end (user) latency.

Use the following basic guidelines to implement the \emph{buffered}
version of InterCom:

\begin{enumerate}
\item Extend (inherit from) the class \texttt{Minimal} to implement a
  new class \texttt{Buffer}.
\item In the payload of the UDP packets a chunk number must be
  included in order to provide to the receiver the information to
  determine where to store the corresponding chunk in the circular
  buffer. Use an unsigned integer of 16 bits for representing the
  chunk numbers.
\item Take into account that the critical part of InterCom is a task
  that could be called \emph{record-send-and-play}, and this should be
  iterated each time a new chunk is available in the ADC. More
  precisely:
  \begin{enumerate}
  \item The recorded chunks must be sent to the interlocutor as soon
    as possible in order to minimize the latency.
  \item The playback of the chunks extracted from the buffer must be
    \emph{seamless} (without the ocurrence of silences) as long as the
    chunks have been received on time.
  \item As always, the lost chunks should be replaced by zero-chunks
    in the playback.
  \end{enumerate}
\item A \emph{receive-and-buffer} task can be run now in a different
  execution thread, decoupled from the \emph{record-send-and-play}
  task. But notice that using \texttt{sounddevice} this can be achived
  without using the \texttt{threading} nor \texttt{multiprocessing}
  libraries because the interruption handler (the so called callback
  function) already runs in parallel with the main thread.
\end{enumerate}

\begin{pseudocode}{Buffer\_InterCom}{~}
  \PROCEDURE{Record\_Send\_and\_Play}{~}
  \BEGIN
    \mathtt{chunk} \GETS \mathtt{record()}\\
    \mathtt{packed\_chunk} \GETS \mathtt{pack(chunk)}\\
    \mathtt{send(packed\_chunk)}\\
    \mathtt{chunk} \GETS \mathtt{unbuffer()}\\
    \mathtt{play(chunk)}
  \END
  \ENDPROCEDURE
  \PROCEDURE{Receive\_and\_Buffer}{~}
  \BEGIN
    \mathtt{packed\_chunk} \GETS \mathtt{receive()}\\
    \mathtt{chunk\_number}, \mathtt{chunk} \GETS \mathtt{unpack(packed\_chunk)}\\
    \mathtt{buffer(chunk\_number, chunk)}
  \END
  \ENDPROCEDURE
\end{pseudocode}


\section{Timming}

Please, finish this milestone in two weeks.

\section{Deliverables}

A python module called \texttt{buffer.py} stored in the root directory
of the intercom's repo.

\section{Resources}

\bibliography{networking}
