\title{\href{https://www.ual.es/estudios/grados/presentacion/plandeestudios/asignatura/4015/40154321?idioma=zh_CN}{TecnologÃ­as Multimedia} - Study Guide - Milestone 5: Minimal InterCom}

\maketitle

\section{Description}

\subsection{Sequential model}

InterCom can be divided roughtky in 6 steps:

\begin{pseudocode}{Sequential\_InterCom}{~}
  \PROCEDURE{Record\_IO\_and\_Play}{~}
  \BEGIN
    \mathtt{recorded\_chunk} \GETS \mathtt{record()}\\
    \mathtt{outgoing\_packet} \GETS \mathtt{pack(recorded\_chunk)}\\
    \mathtt{send(outgoing\_packet)}\\
    \mathtt{incoming\_packet} \GETS \mathtt{receive()}\\
    \mathtt{chunk\_to\_play} \GETS \mathtt{unpack(incoming\_packet)}\\
    \mathtt{play(chunk\_to\_play)}
  \END
  \ENDPROCEDURE
\end{pseudocode}

Where:

\begin{enumerate}
\item $\mathtt{record()}$ captures a chunk of frames. In general, this
  is a \href{https://en.wikipedia.org/wiki/I/O_bound}{I/O-bound}
  \href{https://python-sounddevice.readthedocs.io/en/0.4.0/api/streams.html#sounddevice.Stream.read}{blocking
    operation}~\cite{sounddevice}, depending on the availability of
  frames in the ADC's buffer. This can be checked in
  \href{https://raw.githubusercontent.com/Tecnologias-multimedia/intercom/master/test/sounddevice/wire4.py}{wire4.py}\footnote{
    \texttt{curl https://raw.githubusercontent.com/Tecnologias-multimedia/intercom/master/test/sounddevice/wire4.py > wire4.py}
  },
  where the $\mathtt{read()}$ method always returns inmediately
  because only the available frames are returned in each call (the
  chunk-size depends on the instant of time in which this method is
  called).
\item $\mathtt{pack(chunk)}$ process the chunk to create a
  \href{https://en.wikipedia.org/wiki/Network_packet}{packet} (or a
  sequence of packets), a structure that can be transmitted through
  the Internet using the
  \href{https://en.wikipedia.org/wiki/Datagram}{Datagram} Model. In
  general, this is a
  \href{https://en.wikipedia.org/wiki/CPU-bound}{CPU-bounded}
  (CPU-intensive) operation, and therefore, reduces the number of
  cycles/second that the main thread can reach.
\item $\mathtt{send(packet)}$, sends the packet to the interlocutor's
  InterCom. When datagrams are used, this step is non-blocking neither
  CPU-bounding (the CPU usage is very low), if the number of
  packets/second is small and the size of the payloads is also small,
  as it is expected in the InterCom.
\item $\mathtt{receive()}$, waits (blocking) for a incoming packet,
  and therefore, this operation is IO-bound. However, most
  \href{https://docs.python.org/3/library/socket.html}{socket
    API}s~\cite{python} offeer a
  \href{https://docs.python.org/3.8/library/socket.html#socket.socket.setblocking}{non-blocking
    option} where when a packet is not available in the kernel's
  buffer associanted to the corresponding socket, some kind of
  exception is generated and, in this case, it is resposabability of
  the programmer to generate a ``alternative'' chunk (in our case, for
  example, a chunk filled with zeros will not produce any sound).
\item $\mathtt{unpack(packet)}$ is (as $\mathtt{pack(chunk)}$) a
  CPU-intensive step that transforms a packet (or several packets)
  into a chunk of audio.
\item $\mathtt{play(chunk)}$ renders the chunk. In general, this is an
  I/O-bound
  \href{https://python-sounddevice.readthedocs.io/en/0.4.0/api/streams.html#sounddevice.Stream.write}{blocking}
  action. However, if $\mathtt{play()}$ is called at the same pace
  than $\mathtt{record()}$ and the record and play parameters are
  exactely the same (as happens in our model), the playing of the
  chunk will return inmediately because the time that the
  $\mathtt{play()}$ method needs to complete would exactly match the
  time that the $\mathtt{record()}$ method requires (see
  \texttt{wire4.py}).
\end{enumerate}

This model works fine if the chunk size is controlled by
\href{http://www.portaudio.com/}{PortAudio}~\cite{portaudio}
(\texttt{sounddevice}) and also, the run-time required by
$\mathtt{pack(chunk)}$ and $\mathtt{unpack(packet)}$ operations is
smaller than the chunk-time. The first issue is complicates slightly
the implementation because we need to work with chunks of constantly
changing lenghts (that as you can see, most of the time are 0). This
also complicates the control of the latency (the chunk size is
variable). However, the real problem appears when our computer is not
able to satisfy the second requirement. This only can be addressed
through optimizing and parallelizing the code.

\subsection{Timer-based model}

In this model, the task dedicated to record and play the chunks of
audio is called periodically (probably, using some timer provided by
the sound hardware). This procedure guarantees a gliches-free audio-IO
when constant chunk sizes are used because the timer interruption
coincides exactly with the instant of time in which the
$\mathtt{record()}$ and the $\mathtt{play()}$ methods need to be run
to guarantee that we are going to handle a chunk of audio of a known
size without blocking. The following algorithm describes the new model
that is basically the previous one, except that the chunk size is
controlled.

\begin{pseudocode}{Timer-based\_InterCom}{~}
  \PROCEDURE{Record\_IO\_and\_Play}{\mathtt{chunk\_size}}
  \BEGIN
    \mathtt{recorded\_chunk} \GETS \mathtt{record(chunk\_size)}\\
    \mathtt{send(outgoing\_packet)} \GETS \mathtt{pack(recorded\_chunk)}\\
    \mathtt{send(outgoing\_packet)}\\
    \mathtt{incoming\_packet} \GETS \mathtt{receive()}\\
    \mathtt{chunk\_to\_play} \GETS \mathtt{unpack(incoming\_packet)}\\
    \mathtt{play(chunk\_to\_play)}
  \END
  \ENDPROCEDURE
\end{pseudocode}

\section{What you have to do?}

\begin{enumerate}

\item Implement a timer-based InterCom. Use as reference
  \href{https://github.com/Tecnologias-multimedia/intercom/blob/master/test/sounddevice/wire.py}{wire.py}\footnote{
  \texttt{curl
    https://raw.githubusercontent.com/Tecnologias-multimedia/intercom/master/test/sounddevice/wire.py
    > wire.py} }. Your implementation should be able to record,
  \href{https://github.com/vicente-gonzalez-ruiz/YAPT/blob/master/03-IO/networking/sockets.ipynb}{transmit}~\cite{YAPT}
  (using
  \href{https://en.wikipedia.org/wiki/User_Datagram_Protocol}{UDP}~\cite{UDP})
  and play raw (this means that the
  $\mathtt{pack()}$/$\mathtt{unpack()}$ operations are not required for
    this milestone) audio data between two computers.
  
\end{enumerate}

\section{Timming}

You should reach this milestone at most in two weeks.

\section{Deliverables}

A Python module with the implementation of the minimal InterCom. Name
it \texttt{intercom\_minimal.py}. Store it at the
\href{https://github.com/Tecnologias-multimedia/intercom}{root
  directory} of your \texttt{intercom}'s repo.

\section{Resources}

\bibliography{python, networking, sound}
