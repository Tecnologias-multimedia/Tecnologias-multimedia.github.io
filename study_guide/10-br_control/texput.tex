\input{../definitions}
\title{\TM{} - Study Guide - Milestone 10: Bit-rate control through quantization}

\maketitle

\section{Description}

\subsection{Quantization}
This discussion is reffered only to the
\href{https://en.wikipedia.org/wiki/Quantization_(signal_processing)}{quantization}
of digital signals.

At the hardware level, the samples of audio are usually represented
using \href{https://en.wikipedia.org/wiki/Pulse-code_modulation}{PCM
  (Pulse Code Modulation)}. In a PCM sample, the number of levels that
the signal can take depends on the
\href{https://en.wikipedia.org/wiki/Audio_bit_depth}{number of
  bits/sample} (16 bits in our case).

Another key aspect to consider is that the processing that the
\href{https://en.wikipedia.org/wiki/Auditory_system}{Human Auditory
  System (HAS)} performs to understand audio signals has several
\href{https://en.wikipedia.org/wiki/Psychoacoustics}{\emph{sources} of
  perceptual redundancy}. One of these sources is the
\href{https://en.wikipedia.org/wiki/Equal-loudness_contour}{finite
  number of different volumen levels that a human being can
  recognize}~\cite{bosi2003intro}. In this milestone we will profit of
that fact to decrease the transmission bit-rate by sacrificing
quality.  In most lossy compression systems, quantization is the only
source of distortion~\cite{taubman2002jpeg2000}.

\href{https://en.wikipedia.org/wiki/Quantization_(signal_processing)}{Scalar
  Quantization} (SQ) is the process of decreasing the number of
discrete levels that a signal can
take~\cite{sayood2017introduction}. \href{https://en.wikipedia.org/wiki/Vector_quantization}{Vector
Quantization} (VQ) is similar, but is applied to tuples of samples at
the same time~\cite{vetterli2014foundations}. SQ is used when the
samples are decorrelated or althought are correlated, the decorrelation
will be exploited in
a \href{https://en.wikipedia.org/wiki/Entropy_encoding}{entropy
coding} stage (which is our case with DEFLATE), because the
\href{https://en.wikipedia.org/wiki/Quantization_(signal_processing)#Rate%E2%80%93distortion_optimization}{coding
  efficiency} provided by VQ is marginal in this
context~\cite{vetterli2014foundations}.

Quantizers can also be classified into
\href{https://en.wikipedia.org/wiki/Quantization_(signal_processing)#Mid-riser_and_mid-tread_uniform_quantizers}{uniform}
and
\href{https://nptel.ac.in/content/storage2/courses/117104069/chapter_5/5_5.html}{non-uniform}~\cite{sayood2017introduction,vetterli2014foundations}. An
uniform quantizer distributes the available representation levels
uniformely over the range of input values. Non-uniform quantizers use
higher density of representation levels (more output levels per input
different values) to those intervals of input values that occur more
often. Non-uniform quantizers can also be classified into static and
\href{https://en.wikipedia.org/wiki/Adaptive_differential_pulse-code_modulation}{adaptive
  quantizers}. In the first case, the
\href{https://en.wikipedia.org/wiki/Probability_distribution}{distribution}
of the representation levels remains constant during the quantization
stage, and in the second case, the quantizer parameters are adapted
dinamically to the characteristics of the input signal. In this
milestone we will use an
\href{https://en.wikipedia.org/wiki/Quantization_(signal_processing)#Dead-zone_quantizers}{uniform
  dead-zone scalar static quantizer}, which can be implemented
efficiently for digital signals and that provides a good
\href{https://en.wikipedia.org/wiki/Rate%E2%80%93distortion_theory}{rate/distortion}
  trade-off. See
  \href{https://github.com/vicente-gonzalez-ruiz/quantization/blob/master/digital_quantization.ipynb}{this
    Jupyter notebook} for more information.

\subsection{Rate-control and distortion}
The number of representation levels used by a quantizer depends
basically on the so called quantization step, typically denoted by
$\Delta$. The higher the $\Delta$, the smaller the number of
representation levels, and therefore, the higher the distortion
generated by the quantization error (see
\href{https://github.com/vicente-gonzalez-ruiz/quantization/blob/master/digital_quantization.ipynb}{the
  notebook}), and lileky (depending finally on the entropy encoder),
the smaller the output bit-rate.

The control of the bit-rate through the $\Delta$ values is a technique
that can be used in real-time transmission systems to minimize the
jitter and the loss of packets when
\href{https://en.wikipedia.org/wiki/Network_congestion}{congestion}
occurs. However, notice that depending of the entropy coding stage and
the characteristics of the signal (variance, entropy) may not exist a
clear relationship between the $\Delta$ and the output bit-rate. This
happens using DEFLATE.

Notice that any rate-control algorithm based on quantization has a
characteristic RD (Rate/Distortion) curve, in which the X axis
represents the (in the case of InterCom, received) bit-rate and the Y
axis the distortion in the reconstruction (in the case of InterCom,
the played audio sequence) generated by the quantization.

\subsection{The current implementation(s)}

Bit-rate control through quantization has been implemented in the
class \verb|BR_Contro| of the modules
\texttt{br\_control\{|0|1|2\}.py}. This class overrides the inherited
methods \verb|Compression.pack()| and \verb|Compression.unpack()|,
performing:

\begin{lstlisting}[language=Python]
  def pack(chunk_number, chunk):
    quantized_chunk = quantize(chunk)  # (1)
    packed_chunk = Buffering.pack(chunk_number, quantized_chunk)  # (2)
    return packed_chunk  # (3)
\end{lstlisting}

\begin{lstlisting}[language=Python]
  def unpack(packed_chunk):
    (chunk_number, quantized_chunk) = Buffering.unpack(packed_chunk)  # (1)
    chunk = dequantize(quantized_chunk)  # (2)
    return (chunk_number, chunk)  # (3)
\end{lstlisting}

Notice that you will find four implementations related to this milestone:
\begin{enumerate}
\item \verb|br_control.py|: Uses a constant $\Delta$.
\item \verb|br_control0.py|: Every second runs:
  \begin{equation}
    \begin{array}{l}
      \Delta = \Delta + L \\
      \Delta = \Delta - 1,
    \end{array}
  \end{equation}
  where $L$ is the number of lost (received) chunks in the previous
  second. Notice that this heuristic supposes that the interlocutor is
  lossing (on average) the same number of chunks.
\item \verb|br_control1.py|: Every second runs:
  \begin{equation}
    \Delta = L - 1.
  \end{equation}
\item \verb|br_control2.py|: Every second runs:
  \begin{equation}
    \begin{array}{ll}
      \Delta = 2\Delta & \text{if}~L>1 \\
      \Delta = \frac{1}{2}\Delta & \text{otherwise}.
    \end{array}
  \end{equation}
\end{enumerate}

\section{What you have to do?}

\begin{enumerate}
\item Considering the RMSE (Root Mean Square Error) as distortion
  measure, generate the RD curve considering a set of different
  simulated transmission environments (use
  \href{https://man7.org/linux/man-pages/man8/tc.8.html}{tc}) of the
  song ``\verb|InterCom/data/Aviador Dro - La Zona Fantasma.oga|'',
  for the four implementations.
\end{enumerate}

\section{Timming}

Please, finish this milestone at most in one week.

\section{Deliverables}

A report with the RD curves and the data necessary to redo the curves.

\section{Resources}

\bibliography{JPEG2000,audio-coding,data-compression,signal-processing}
