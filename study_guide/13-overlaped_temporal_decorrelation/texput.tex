\input{../definitions}
\title{\TM{} - Study Guide - Milestone 13: Overlapped temporal decorrelation}

\maketitle

\section{Description}

\subsection{\href{https://en.wikipedia.org/wiki/Lapped_transform}{Overlapped transforms} for minimizing the distortion}
Transform coding implies to split the signal into chunks, and to
compute the transform of each chunk. When the output coefficients are
quantized, it is possible that significative (and unpleasant)
distortions may appear between the boder samples of the chunks (see
this
\href{https://github.com/Tecnologias-multimedia/intercom/blob/master/docs/quantization_DWT.ipynb}{notebook}).

One solution is to use the last samples of the $i+1$-th chunk and the
first samples of the $i+1$-th chunk for computing the transform of the
$i$-th chunk.

A final (and important) consideration about transform coding and
quantization. Transform coding implies splitting the signal into
chunks, and computing the transform of each chunk. When the
coefficients are quantized, it is possible that significative (and
unpleasant) distortions may appear between the border samples of the
chunks (see this
\href{https://github.com/Tecnologias-multimedia/intercom/blob/master/docs/quantization_DWT.ipynb}{notebook}). One
simple solution is to use the last samples of the $i-1$-th chunk and
the first samples of the $i+1$-chunk for computing the transform of
the $i$-th chunk (notice that this
\href{https://en.wikipedia.org/wiki/Lapped_transform}{overlapping} does
not imply to generate more transform coefficients, but only to avoid
using an artificial
\href{https://pywavelets.readthedocs.io/en/latest/ref/signal-extension-modes.html}{signal
  extension} at the limits of the chunks). The number of overlaped
samples depends on the length of the filters and the number of levels
$s$ of the DWT. This last parameter (the number of levels of the DWT)
has also a high impact on the decorrelation process, but take into
consideration that, depending on the signal, usually happens that it
is not worth decomposing the signal into the maximum number of
subbands because the increase in the coding gain can be negligible
beyond a number of levels (typically, $5$).
  
\section{What you have to do?}

\begin{enumerate}
\item In a module named temporal\_decorrelate.py, inherit the class
  Stereo\_decorrelation and create a class named Temporal\_decorrelation.
\item Select a suitable\footnote{Take into consideration the subband
    gains and the shape of the wavelet functions in your wavelet
    selection.} DWT from
  \href{https://pywavelets.readthedocs.io/en/latest/}{PyWavelets} and
  transform the MST subbands. Take also into consideration that the
  signal should be processed using overlaped chunks in order to
  minimize the discontinuities of the reconstructed signal at the
  chunk boundaries, when the DWT coefficients are
  quantized. Obviously, implement also the inverse stuff for
  recovering the audio signal.
\item Compare the RD (Rate/Distortion) curves generated by the modules
  br\_control.py, stereo\_decorrelate.py and temporal\_decorrelate.py.
\end{enumerate}

\section{Timming}

This is the final milestone. Present your results in the exam time.

\section{Deliverables}

The module temporal.py. Store it at the
\href{https://github.com/Tecnologias-multimedia/intercom}{root
  directory} of your InterCom's repo.

\section{Resources}

\bibliography{maths,data-compression,DWT,audio-coding}

\begin{comment}

  The Figure~\ref{fig:transform_coding} shows the stages that are
  tipycally involved in a transform-based signal compression system.

\begin{figure}
  \begin{center}
\begin{verbatim}
   s   +---+   w    +---+   k    +---+    c
 ----->| T |------->| Q |------->| E |-----------+
  (s)  +---+  (s)   +---+  (~s)  +---+   (~s)    |
samples   coefficients   indexes      code-words ~
                                                 :
                                                 ~
   ~s  +---+    w   +---+   k    +---+           |
 <-----| t |<-------| q |<-------| D |<----------+
  (~s) +---+  (~s)  +---+  (~s)  +---+
approx.    quantized     indexes
samples   coefficients
\end{verbatim}                
  \end{center}
  \caption{Common data-flow used un Transform Coding. $s$ represents
    the signal to compress, $\tilde{s}$ the lossy version of the
    reconstructed signal, $T$ the (forward) transform (which takes blocks of
    samples) producing blocks of coefficients $w$, $Q$ the scalar
    quantization stage (which takes single coefficients) producing
    quantization indexes $k$, $E$ the entropy encoder (which in our
    case (DEFLATE) works with blocks of coefficients) producing
    code-words $c$, $D$ the entropy decoder, $q$ the decuantization
    stage, and $t$ the inverse (or backward) transform. PCM stands for Puse Code
    Modulation and DEFLATE is the technique used to find a compact
    representation of the quantized coefficients.}
  \label{fig:transform_coding}
\end{figure}
\end{comment}

