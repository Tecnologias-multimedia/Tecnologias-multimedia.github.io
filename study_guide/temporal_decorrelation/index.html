<!DOCTYPE html> 
<html> 
<head> <title>TecnologÃŋas Multimedia - Study Guide - Milestone 12: Temporal decorrelation
in audio signals</title> 
<meta charset="UTF-8" /> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)" /> 
<link rel="stylesheet" type="text/css" href="index.css" /> 
<script type="text/javascript" 
src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" 
></script> 
<style type="text/css"> 
.MathJax_MathML {text-indent: 0;} 
</style> 
</head><body 
>
   <div class="maketitle">
                                                                  

                                                                  
                                                                  

                                                                  

<h2 class="titleHead"><a 
href="https://www.ual.es/estudios/grados/presentacion/plandeestudios/asignatura/4015/40154321?idioma=zh_CN" >Tecnologías Multimedia</a> - Study Guide -
Milestone 12: Temporal decorrelation in audio
signals</h2>
 <div class="author" ><a 
href="https://cms.ual.es/UAL/personas/persona.htm?id=515256515553484875" ><span 
class="ecrm-1200">Vicente Gonz</span><span 
class="ecrm-1200">á</span><span 
class="ecrm-1200">lez Ruiz</span></a> <span 
class="ecrm-1200">- </span><a 
href="https://cms.ual.es/UAL/universidad/departamentos/informatica/index.htm" ><span 
class="ecrm-1200">Depto Inform</span><span 
class="ecrm-1200">á</span><span 
class="ecrm-1200">tica</span></a> <span 
class="ecrm-1200">- </span><a 
href="https://www.ual.es" ><span 
class="ecrm-1200">UAL</span></a></div><br />
<div class="date" ><span 
class="ecrm-1200">December 6, 2020</span></div>
   </div>
   <h3 class="sectionHead"><span class="titlemark">1   </span> <a 
 id="x1-10001"></a>Description</h3>
<!--l. 8--><p class="noindent" >After removing the spatial (stereo) redundancy in the previous milestone, the next natural
step in its development is the removal of the temporal redundancy that can be found inside of
each subband<span class="footnote-mark"><a 
href="index2.html#fn1x0"><sup class="textsuperscript">1</sup></a></span><a 
 id="x1-1001f1"></a> .
As it can be seen in this notebook, most audio signals show “patterns” of samples
that tends to repeat, especially locally. Another clear source of temporal
redundancy is that the neighbor audio samples usually show similar amplitude
values.
</p><!--l. 22--><p class="indent" >   There are several techniques that can be used for removing the temporal
redundancy from a sequence of audio. One of the most straightforward is <a 
href="https://en.wikipedia.org/wiki/Differential_pulse-code_modulation" >Diﬀerential
Pulse Code Modulation (DPCM) <span class="cite">[<a 
href="#Xsayood2017introduction">3</a>]</span></a>. However, there are more eﬃcient decorrelation
algorithms based on <a 
href="https://en.wikipedia.org/wiki/Transform_coding" >transform coding</a>, such the used in the previous milestone and in
this one.
</p><!--l. 33--><p class="indent" >   Transform coding is based on the idea that we can decompose (we can generate a
decomposition from) the input signal into a set of subbands, and if the used
                                                                  

                                                                  
ﬁlters<span class="footnote-mark"><a 
href="index3.html#fn2x0"><sup class="textsuperscript">2</sup></a></span><a 
 id="x1-1002f2"></a> 
are the adecuate for removing the temporal redundancy, we can achieve a
high transform <a 
href="https://en.wikipedia.org/wiki/Coding_gain" >coding gain</a>, accumulating most of the signal energy (and
presumably most of the information) in a small number of subbands. When this
happens, the quantization of the coeﬃcients of the subbands will remove
basically the least signiﬁcant information, allowing better compression ratios
than those in which we apply the same quantization process to the original
samples.<span class="footnote-mark"><a 
href="index4.html#fn3x0"><sup class="textsuperscript">3</sup></a></span><a 
 id="x1-1003f3"></a> 
</p><!--l. 53--><p class="indent" >   The name that has been given to the previous process is
<a 
href="https://en.wikipedia.org/wiki/Sub-band_coding" >subband coding</a>. In this context, our analysis transform matrix
<!--l. 55--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>K</mi></math> (see
the previous milestone) represents the coeﬃcients (or <a 
href="https://en.wikipedia.org/wiki/Finite_impulse_response" >taps</a>) of a 2-channels
analysis <a 
href="https://en.wikipedia.org/wiki/Filter_bank" >Filter Bank (FB)</a>, and the forward transform is in fact “descomposing”
<!--l. 60--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>x</mi></math> into two
subbands <!--l. 61--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>w</mi></mrow><mrow 
><mn>0</mn></mrow></msub 
></math>
and <!--l. 61--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>w</mi></mrow><mrow 
><mn>1</mn></mrow></msub 
></math>
(see the Figure <span 
class="ecbx-1000">??</span>, and this notebook). On the other hand, the synthesis transform
matrix <!--l. 63--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msup><mrow 
><mi 
>K</mi></mrow><mrow 
><mo 
class="MathClass-bin">−</mo><mn>1</mn></mrow></msup 
></math>
denotes the taps of a synthesis FB.
</p><!--l. 66--><p class="indent" >   Let’s suppose now that the ﬁlters (represented by the taps of)
<!--l. 66--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>K</mi></mrow><mrow 
><mn>0</mn></mrow></msub 
></math> and
<!--l. 67--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>K</mi></mrow><mrow 
><mn>1</mn></mrow></msub 
></math> are applied to the input signal
<!--l. 67--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>x</mi></math>.<span class="footnote-mark"><a 
href="index5.html#fn4x0"><sup class="textsuperscript">4</sup></a></span><a 
 id="x1-1004f4"></a> 
Let’s also suppose (as happens in the MST) that
<!--l. 71--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>K</mi></mrow><mrow 
><mn>0</mn></mrow></msub 
></math> is a low-pass ﬁlter and
<!--l. 71--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>K</mi></mrow><mrow 
><mn>1</mn></mrow></msub 
></math> is a high-pass ﬁlter, and
that the <a 
href="https://en.wikipedia.org/wiki/Filter_(signal_processing)#The_transfer_function" >transfer function</a><span class="footnote-mark"><a 
href="index6.html#fn5x0"><sup class="textsuperscript">5</sup></a></span><a 
 id="x1-1005f5"></a> 
of both ﬁlters <a 
href="https://en.wikipedia.org/wiki/Filter_bank#Perfect_reconstruction_filter_banks" >are the inverse of each other</a>. Under these assumptions, the complete
(analysis/synthesis) system is called a (2-channels) <a 
href="https://en.wikipedia.org/wiki/Filter_bank#Perfect_reconstruction_filter_banks" >Perfect Reconstruction Filter Bank
(PRFB)</a>, and <!--l. 81--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>x</mi></math>
can be recoverd from a subsampled version (in this case <a 
href="https://en.wikipedia.org/wiki/Downsampling_(signal_processing)" >decimating</a> by 2) of
<!--l. 84--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>w</mi></mrow><mrow 
><mn>0</mn></mrow></msub 
></math> and
                                                                  

                                                                  
<!--l. 84--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>w</mi></mrow><mrow 
><mn>1</mn></mrow></msub 
></math> (see
the notebook).
</p><!--l. 87--><p class="indent" >   Using the suitable ﬁlters, it is possible to build
<!--l. 87--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>M</mi></math>-channels
PRFBs.<span class="footnote-mark"><a 
href="index7.html#fn6x0"><sup class="textsuperscript">6</sup></a></span><a 
 id="x1-1006f6"></a> 
These ﬁlters can analyze (and synthesize) the signal
<!--l. 89--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>x</mi></math>,
decomposing it in (<a 
href="https://en.wikipedia.org/wiki/Low-pass_filter#Ideal_and_real_filters" >almost for sure</a>) overlaping frequency subbands with diﬀerent
bandwidth. The question here is how many ﬁlters should be used and what
bandwidth should they have. At this design point, we must consider also that the
accuracy of the humman perception of the sound depends on the frequency: (as it can
be seen in this notebook) we are more sensitive to frequency variations when the
frequency of the sound is low. This fact is related with the existence of <a 
href="https://en.wikipedia.org/wiki/Bark_scale" >the bark
scale</a>.
</p><!--l. 102--><p class="indent" >   The bark scale divides the audible spectrum into 24 subband of (a priori)
“whimsical” bandwidths. However, it’s clear that a <a 
href="https://en.wikipedia.org/wiki/Octave_band" >dyadic partition of the spectrum</a>
ﬁts better than <a 
href="https://en.wikipedia.org/wiki/Wavelet_transform#Principle" >a lineal partition</a>. Considering this reason, from all the transforms
designed to date, the most suitable one from a strict frequency if the Discrete
Wavelet Transform (DWT).
</p><!--l. 112--><p class="indent" >   The DWT has also other interesting features:
     </p><ol  class="enumerate1" >
     <li 
  class="enumerate" id="x1-1008x1">It is <a 
href="https://en.wikipedia.org/wiki/Discrete_wavelet_transform#Time_complexity" >fast (<!--l. 116--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>O</mi><mrow ><mo 
class="MathClass-open">(</mo><mrow><mi 
>N</mi></mrow><mo 
class="MathClass-close">)</mo></mrow></math>,
     where <!--l. 116--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>N</mi></math>
     is the number of “transformed” elements)</a>.
     </li>
     <li 
  class="enumerate" id="x1-1010x2">Can represent eﬃcienty <a 
href="https://en.wikipedia.org/wiki/Transient_(oscillation)" >transient</a> signals, which can happen frequencly in
     audio.
     </li>
     <li 
  class="enumerate" id="x1-1012x3">Although we are not going to take advantage of the following characteristic
     (for now), one of the most interesting features of the DWT is that it can
     used to ﬁnd easely a <a 
href="https://en.wikipedia.org/wiki/Multiresolution_analysis" >multiresolution representation</a> of the signal.</li></ol>
<!--l. 128--><p class="indent" >   The DWT can be implemented in diﬀerent ways:
     </p><ol  class="enumerate1" >
     <li 
  class="enumerate" id="x1-1014x1">Deﬁning <!--l. 130--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>K</mi></math>
     and computing vector-matrix multiplications, which requires a calculation
     time proportional to <!--l. 131--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>O</mi><mrow ><mo 
class="MathClass-open">(</mo><mrow><msup><mrow 
><mi 
>N</mi></mrow><mrow 
><mn>2</mn></mrow></msup 
></mrow><mo 
class="MathClass-close">)</mo></mrow></math>.
     However, the main problem of this type of implementation is generated by
     the memory that <!--l. 133--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>K</mi></math>
     can require, that is proportional to <!--l. 133--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msup><mrow 
><mi 
>N</mi></mrow><mrow 
><mn>2</mn></mrow></msup 
></math>.
                                                                  

                                                                  
     </li>
     <li 
  class="enumerate" id="x1-1016x2"><a 
href="https://en.wikipedia.org/wiki/Discrete_wavelet_transform#Cascading_and_filter_banks" >Cascading PRFBs</a>. Considering that the convolution is a <!--l. 136--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>O</mi><mrow ><mo 
class="MathClass-open">(</mo><mrow><mi 
>N</mi><msub><mrow 
><mi class="qopname">log</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--></mrow><mrow 
><mn>2</mn></mrow></msub 
><mi 
>N</mi></mrow><mo 
class="MathClass-close">)</mo></mrow></math>
     operation, and that the number the number of levels in the cascade is
     generally small (5 for example), this implementation is faster than the
     based in vector-matrix arithmetic. And most importantly, we don’t need to
     store <!--l. 140--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>K</mi></math>,
     but only the taps of the ﬁlters.
     </li>
     <li 
  class="enumerate" id="x1-1018x3">Using <a 
href="https://en.wikipedia.org/wiki/Lifting_scheme" >lifting</a>, which provides a speed-up factor of 2. DWTs implemented
     with lifting do not need to downsample and upsample the subbands, an
     operation that is wasting the calculus of half of the coeﬃcients at each
     level of the cascade.</li></ol>
<!--l. 185--><p class="indent" >   There exist docens of suitable transform used in TC. They are characterized by
the <a 
href="https://en.wikipedia.org/wiki/Orthogonality" >orthogonality</a> property, which basically means that the output coeﬃcients are
going to be decorrelated because the functions (or vectors, depending on the
terminology) that describe the transform are <a 
href="https://en.wikipedia.org/wiki/Orthogonal_functions" >orthogonal</a> and therefore, form a <a 
href="https://en.wikipedia.org/wiki/Basis_(linear_algebra)" >basis
(set)</a> with which is possible to describe any signal in terms (usually as a linear
combination) of the (basis) functions of such basis, i.e., are able to describe any
signal in the vector space spanned by the basis, using an unique description (set of
coeﬃcients) <span class="cite">[]</span>.
</p><!--l. 200--><p class="indent" >   Wavelets and Wavelet Transforms
</p><!--l. 204--><p class="indent" >   Other major family of transform used in TC forms bi-orthogonal basis (sets). In
this case,
</p><!--l. 207--><p class="indent" >   In this milestone we will use an orghogonal wavelet transform. This makes that
the quantization of the coeﬃcients can be uniform, i.e., we can use the same
quantization step for all the coeﬃcients.
</p><!--l. 211--><p class="indent" >   In the transform described in the previous milestone, the concept of subband is
degradated because we have only one coeﬃcient per subband.
</p><!--l. 213--><p class="indent" >   The coeﬃcient <!--l. 213--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>w</mi><mrow ><mo 
class="MathClass-open">[</mo><mrow><mn>0</mn></mrow><mo 
class="MathClass-close">]</mo></mrow></math>
is called the DC (Direct Current) coeﬃcient, and the rest of coeﬃcients are called AC
(Alternating Current) coeﬃcients.
</p><!--l. 215--><p class="indent" >   <a 
href="https://en.wikipedia.org/wiki/Correlation_and_dependence" >Correlation</a> is a term used in statistics which refer to the interdependency
between two <a 
href="https://en.wikipedia.org/wiki/Random_variable" >random variables</a>. It can be measured by the <a 
href="https://www.mathsisfun.com/data/correlation.html" >correlation coeﬃcient</a> <span class="cite">[<a 
href="#Xthinkstats">2</a>]</span>.
</p><!--l. 222--><p class="indent" >   In the case of InterCom, the random variables are the two channels (left
<!--l. 223--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>L</mi></math> and
right <!--l. 223--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>R</mi></math>)
of the <a 
href="https://en.wikipedia.org/wiki/Stereophonic_sound" >stereo <a 
href="https://en.wikipedia.org/wiki/Pulse-code_modulation" >PCM</a> signal</a> <span class="cite">[<a 
href="#Xbosi2003intro">1</a>]</span>. In most cases, both channels are
going to be <a 
href="https://en.wikipedia.org/wiki/Binaural_recording" >highly correlated</a> (especially if the microphone is mono),
which means that we can represent one of them (for example, the
<!--l. 229--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>R</mi></math> channel) with respect
to the other (the <!--l. 230--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>L</mi></math>
channel). From a mathematical point of view, this process can be seen as a
<a 
href="https://en.wikipedia.org/wiki/Decorrelation" >decorrelation</a> process. From a physical perspective, decorrelating implies energy
accumulation in a few coeﬃcients <span class="cite">[<a 
href="#Xsayood2017introduction">3</a>]</span>.
                                                                  

                                                                  
</p><!--l. 236--><p class="indent" >   To perform this inter-channel decorrelation, we can use an
<a 
href="https://en.wikipedia.org/wiki/Orthogonal_transformation" >orthogonal</a><span class="footnote-mark"><a 
href="index8.html#fn7x0"><sup class="textsuperscript">7</sup></a></span><a 
 id="x1-1019f7"></a> 
transform, that in the case of decorrelating a stereo signal is </p><table class="equation"><tr><td> <a 
 id="x1-1020r1"></a>
<!--l. 241--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
<mi 
>y</mi> <mo 
class="MathClass-rel">=</mo> <mi 
>K</mi><mi 
>x</mi> <mo 
class="MathClass-rel">=</mo> <mfrac><mrow 
><mn>1</mn></mrow> 
<mrow 
><mn>2</mn></mrow></mfrac> <mfenced separators="" 
open="["  close="]" ><mrow><mtable  align="axis" style=""  
equalrows="false" columnlines="none none none none none none none none none" equalcolumns="false" class="array"><mtr><mtd 
class="array"  columnalign="center"> <mn>1</mn> </mtd><mtd 
class="array"  columnalign="center">   <mn>1</mn>   </mtd></mtr> <mtr><mtd 
class="array"  columnalign="center"> <mn>1</mn> </mtd> <mtd 
class="array"  columnalign="center"> <mo 
class="MathClass-bin">−</mo><mn>1</mn></mtd></mtr> <!--*\c@MaxMatrixCols c--></mtable>                                                                                         </mrow></mfenced><mi 
>x</mi><mo 
class="MathClass-punc">,</mo>
</math></td><td class="eq-no">(1)</td></tr></table>
<!--l. 244--><p class="indent" >   where <!--l. 244--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>x</mi></math>
represents a frame (a tuple of L and R samples,
<!--l. 244--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>x</mi><mrow ><mo 
class="MathClass-open">[</mo><mrow><mn>0</mn></mrow><mo 
class="MathClass-close">]</mo></mrow></math> and
<!--l. 245--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>x</mi><mrow ><mo 
class="MathClass-open">[</mo><mrow><mn>1</mn></mrow><mo 
class="MathClass-close">]</mo></mrow></math>),
<!--l. 245--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>K</mi></math> is the
<!--l. 245--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mn>2</mn> <mo 
class="MathClass-bin">×</mo> <mn>2</mn></math>
KLT <a 
href="http://fourier.eng.hmc.edu/e161/lectures/klt/node3.html" >(Karhunen-Loève Transform)</a> matrix multiplied by
<!--l. 247--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mn>1</mn><mo 
class="MathClass-bin">∕</mo><msqrt><mrow><mn>2</mn></mrow></msqrt></math>
(which is closely related to the <a 
href="http://wavelets.pybytes.com/wavelet/haar/" >Haar transform</a> <span class="cite">[<a 
href="#Xvetterli1995wavelets">5</a>]</span>), and
<!--l. 249--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>y</mi></math>
represents the transform coeﬃcients (in our case, a couple of coeﬃcients
<!--l. 250--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>y</mi><mrow ><mo 
class="MathClass-open">[</mo><mrow><mn>0</mn></mrow><mo 
class="MathClass-close">]</mo></mrow></math> with the
<a 
href="https://en.wikipedia.org/wiki/Arithmetic_mean" >mean</a> and <!--l. 252--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>y</mi><mrow ><mo 
class="MathClass-open">[</mo><mrow><mn>1</mn></mrow><mo 
class="MathClass-close">]</mo></mrow></math>
with the diﬀerence of the samples). Notice that this transform is not <a 
href="https://en.wikipedia.org/wiki/Orthonormal_basis" >orthonormal</a>
(energy preserving in the transform domain) because </p><table class="equation"><tr><td> <a 
 id="x1-1021r2"></a>
<!--l. 256--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                       <mo  
>∑</mo>
  <mi 
>y</mi><msup><mrow 
><mrow ><mo 
class="MathClass-open">[</mo><mrow><mi 
>i</mi></mrow><mo 
class="MathClass-close">]</mo></mrow></mrow><mrow 
><mn>2</mn></mrow></msup 
> <mo 
class="MathClass-rel">=</mo>  <mfrac><mrow 
><mn>1</mn></mrow> 
<mrow 
><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></mfrac><mo  
>∑</mo>
   <mi 
>x</mi><msup><mrow 
><mrow ><mo 
class="MathClass-open">[</mo><mrow><mi 
>i</mi></mrow><mo 
class="MathClass-close">]</mo></mrow></mrow><mrow 
><mn>2</mn></mrow></msup 
><mo 
class="MathClass-punc">,</mo>
</math></td><td class="eq-no">(2)</td></tr></table>
                                                                  

                                                                  
<!--l. 259--><p class="indent" >   although both subbands <!--l. 259--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>y</mi><mrow ><mo 
class="MathClass-open">[</mo><mrow><mn>0</mn></mrow><mo 
class="MathClass-close">]</mo></mrow></math>
and <!--l. 259--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>y</mi><mrow ><mo 
class="MathClass-open">[</mo><mrow><mn>1</mn></mrow><mo 
class="MathClass-close">]</mo></mrow></math> have the
same gain (<!--l. 260--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mfrac><mrow 
><mn>1</mn></mrow>
<mrow 
><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></mfrac></math>,
and therefore the same “importance” for a future <a 
href="https://en.wikipedia.org/wiki/Quantization_(signal_processing)" >quantization</a> of
<!--l. 263--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>y</mi></math>). The
described transform is similar to the so called <a 
href="https://en.wikipedia.org/wiki/Joint_encoding#M/S_stereo_coding" >M/S stereo coding</a>, but in our case, the
división by 2 is carried on the forward transform, instead of the backward (inverse)
transform.
</p><!--l. 268--><p class="indent" >   This transform can be implemented <a 
href="https://en.wikipedia.org/wiki/In-place_algorithm" ><span 
class="ecti-1000">in-place</span></a> using the following algorithm:
<a 
 id="x1-1022r1"></a>
<!--l. 287--><p class="noindent" ></p><div class="minipage"><span 
class="ecbx-1000">Algorithm</span>
<span 
class="ecbx-1000">1.1:</span> <span 
class="eccc1000-"><span 
class="small-caps">I</span><span 
class="small-caps">n</span><span 
class="small-caps">t</span><span 
class="small-caps">e</span><span 
class="small-caps">r</span><span 
class="small-caps">-</span><span 
class="small-caps">c</span><span 
class="small-caps">h</span><span 
class="small-caps">a</span><span 
class="small-caps">n</span><span 
class="small-caps">n</span><span 
class="small-caps">e</span><span 
class="small-caps">l</span><span 
class="small-caps">_</span><span 
class="small-caps">d</span><span 
class="small-caps">e</span><span 
class="small-caps">c</span><span 
class="small-caps">o</span><span 
class="small-caps">r</span><span 
class="small-caps">r</span><span 
class="small-caps">e</span><span 
class="small-caps">l</span><span 
class="small-caps">a</span><span 
class="small-caps">t</span><span 
class="small-caps">i</span><span 
class="small-caps">o</span><span 
class="small-caps">n</span></span>(<!--l. 272--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
> </mi></math>)<br 
class="newline" /> <!--l. 272--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mtable  align="axis" style=""  
equalrows="false" columnlines="none" equalcolumns="false" class="array"> <mtr><mtd 
class="array"  columnalign="left"><mspace width="4.3045pt"/> <mstyle 
class="mbox"><mtext  >procedure </mtext></mstyle><mstyle 
class="mbox"><mtext  ></mtext><mtext class="textsc" mathvariant="normal" >analyze</mtext></mstyle><mrow ><mo 
class="MathClass-open">(</mo><mrow><mstyle 
class="text"><mtext  >frame</mtext></mstyle></mrow><mo 
class="MathClass-close">)</mo></mrow>                                                            </mtd>
</mtr>  <mtr><mtd 
class="array"  columnalign="left"><mspace width="4.3045pt"/>  <mtable  align="axis" style=""  
equalrows="false" equalcolumns="false" class="array"> <mtr><mtd 
class="array"  columnalign="left"><mspace width="4.3045pt"/>  <mfenced separators="" 
open="{"  close="" ><mrow> <mtable  align="axis" style=""  
equalrows="false" columnlines="none" equalcolumns="false" class="array"> <mtr><mtd 
class="array"  columnalign="left"><mstyle 
class="text"><mtext  >frame</mtext></mstyle><mrow ><mo 
class="MathClass-open">[</mo><mrow><mn>0</mn></mrow><mo 
class="MathClass-close">]</mo></mrow><mo 
class="MathClass-bin">−</mo> <mo 
class="MathClass-rel">=</mo> <mstyle 
class="text"><mtext  >frame</mtext></mstyle><mrow ><mo 
class="MathClass-open">[</mo><mrow><mn>1</mn></mrow><mo 
class="MathClass-close">]</mo></mrow>     </mtd>
</mtr>  <mtr><mtd 
class="array"  columnalign="left"><mstyle 
class="text"><mtext  >frame</mtext></mstyle><mrow ><mo 
class="MathClass-open">[</mo><mrow><mn>1</mn></mrow><mo 
class="MathClass-close">]</mo></mrow><mo 
class="MathClass-bin">+</mo> <mo 
class="MathClass-rel">=</mo> <mrow ><mo 
class="MathClass-open">(</mo><mrow><mstyle 
class="text"><mtext  >frame</mtext></mstyle><mrow ><mo 
class="MathClass-open">[</mo><mrow><mn>0</mn></mrow><mo 
class="MathClass-close">]</mo></mrow><mo 
class="MathClass-bin">∕</mo><mn>2</mn></mrow><mo 
class="MathClass-close">)</mo></mrow></mtd>
</mtr>  <mtr><mtd 
class="array"  columnalign="left"><mstyle 
class="text"><mtext  >frame</mtext></mstyle><mrow ><mo 
class="MathClass-open">[</mo><mrow><mn>0</mn></mrow><mo 
class="MathClass-close">]</mo></mrow><mo 
class="MathClass-bin">∕</mo> <mo 
class="MathClass-rel">=</mo> <mn>2</mn>               </mtd></mtr><!--@{}lr@{}--></mtable>                                                         </mrow></mfenced></mtd>
 </mtr><!--@{\pcode@tab {1}}l@{}--></mtable>                                                                                                  </mtd>
</mtr>  <mtr><mtd 
class="array"  columnalign="left"><mspace width="4.3045pt"/> <mstyle 
class="mbox"><mtext  >procedure </mtext></mstyle><mstyle 
class="mbox"><mtext  ></mtext><mtext class="textsc" mathvariant="normal" >synthesize</mtext></mstyle><mrow ><mo 
class="MathClass-open">(</mo><mrow><mstyle 
class="text"><mtext  >frame</mtext></mstyle></mrow><mo 
class="MathClass-close">)</mo></mrow>                                                        </mtd>
</mtr>  <mtr><mtd 
class="array"  columnalign="left"><mspace width="4.3045pt"/>  <mtable  align="axis" style=""  
equalrows="false" equalcolumns="false" class="array"> <mtr><mtd 
class="array"  columnalign="left"><mspace width="4.3045pt"/>  <mfenced separators="" 
open="{"  close="" ><mrow> <mtable  align="axis" style=""  
equalrows="false" columnlines="none" equalcolumns="false" class="array"> <mtr><mtd 
class="array"  columnalign="left"><mstyle 
class="text"><mtext  >frame</mtext></mstyle><mrow ><mo 
class="MathClass-open">[</mo><mrow><mn>0</mn></mrow><mo 
class="MathClass-close">]</mo></mrow><mo 
class="MathClass-bin">∗</mo> <mo 
class="MathClass-rel">=</mo> <mn>2</mn>               </mtd>
</mtr>  <mtr><mtd 
class="array"  columnalign="left"><mstyle 
class="text"><mtext  >frame</mtext></mstyle><mrow ><mo 
class="MathClass-open">[</mo><mrow><mn>1</mn></mrow><mo 
class="MathClass-close">]</mo></mrow><mo 
class="MathClass-bin">−</mo> <mo 
class="MathClass-rel">=</mo> <mrow ><mo 
class="MathClass-open">(</mo><mrow><mstyle 
class="text"><mtext  >frame</mtext></mstyle><mrow ><mo 
class="MathClass-open">[</mo><mrow><mn>0</mn></mrow><mo 
class="MathClass-close">]</mo></mrow><mo 
class="MathClass-bin">∕</mo><mn>2</mn></mrow><mo 
class="MathClass-close">)</mo></mrow></mtd>
</mtr>  <mtr><mtd 
class="array"  columnalign="left"><mstyle 
class="text"><mtext  >frame</mtext></mstyle><mrow ><mo 
class="MathClass-open">[</mo><mrow><mn>0</mn></mrow><mo 
class="MathClass-close">]</mo></mrow><mo 
class="MathClass-bin">+</mo> <mo 
class="MathClass-rel">=</mo> <mstyle 
class="text"><mtext  >frame</mtext></mstyle><mrow ><mo 
class="MathClass-open">[</mo><mrow><mn>1</mn></mrow><mo 
class="MathClass-close">]</mo></mrow>     </mtd></mtr><!--@{}lr@{}--></mtable>                                                         </mrow></mfenced></mtd>
 </mtr><!--@{\pcode@tab {1}}l@{}--></mtable>                                                                                                  </mtd>
</mtr>  <mtr><mtd 
class="array"  columnalign="left"><mspace width="4.3045pt"/>                                                                                                   </mtd></mtr><!--@{\pcode@tab {1}}lr@{}--></mtable></math></div>
</p><!--l. 289--><p class="indent" >   where <!--l. 289--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mstyle 
class="text"><mtext  >a</mtext></mstyle><mi 
> </mi><mstyle mathvariant="monospace"><mi 
>O</mi><mi 
>P</mi><mi 
>E</mi><mi 
>R</mi></mstyle> <mo 
class="MathClass-rel">=</mo> <mstyle 
class="text"><mtext  >b</mtext></mstyle></math> is a shorter
representation of the operation <!--l. 290--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mstyle 
class="text"><mtext  >a</mtext></mstyle> <mo 
class="MathClass-rel">=</mo> <mstyle 
class="text"><mtext  >a</mtext></mstyle><mi 
> </mi><mstyle mathvariant="monospace"><mi 
>O</mi><mi 
>P</mi><mi 
>E</mi><mi 
>R</mi></mstyle><mi 
> </mi><mstyle 
class="text"><mtext  >b</mtext></mstyle></math>.
Notice that this type of in-place computations are commonly used in the
implementation of DWTs (<a 
href="https://en.wikipedia.org/wiki/Discrete_wavelet_transform" >Dicrete Wavelet Transform</a>s) using <a 
href="https://cm-bell-labs.github.io/who/wim/papers/athome/athome.pdf" >the Lifting
Scheme</a> <span class="cite">[<a 
href="#X2006.sweldens">4</a>]</span>.
</p>
   <h3 class="sectionHead"><span class="titlemark">2   </span> <a 
 id="x1-20002"></a>What you have to do?</h3>
<!--l. 299--><p class="noindent" >
     </p><ol  class="enumerate1" >
     <li 
  class="enumerate" id="x1-2002x1">In a module named stereo.py, inherit the class Quantization and create a
     class named Stereo_decorrelation.
     </li>
     <li 
  class="enumerate" id="x1-2004x2">Override   the   methods   pack()   and   unpack().   In   pack()   perform
     the  procedure  analyze()  previously  described,  and  in  unpack()  the
     synthesize(). These procedures should be applied to all the frames of a
     chunk using <a 
href="https://www.oreilly.com/library/view/python-for-data/9781449323592/ch04.html" >vectorized operations</a>.
                                                                  

                                                                  
     </li>
     <li 
  class="enumerate" id="x1-2006x3">Has been the <a 
href="https://en.wikipedia.org/wiki/Data_compression_ratio" >compression ratio</a> improved (on <a 
href="https://en.wikipedia.org/wiki/Average" >average</a>)? How much?</li></ol>
<!--l. 314--><p class="noindent" >
</p>
   <h3 class="sectionHead"><span class="titlemark">3   </span> <a 
 id="x1-30003"></a>Timming</h3>
<!--l. 316--><p class="noindent" >You should reach this milestone at most one week.
</p><!--l. 318--><p class="noindent" >
</p>
   <h3 class="sectionHead"><span class="titlemark">4   </span> <a 
 id="x1-40004"></a>Deliverables</h3>
<!--l. 320--><p class="noindent" >The module stereo.py. Store it at the <a 
href="https://github.com/Tecnologias-multimedia/intercom" >root directory</a> of your InterCom’s repo.
</p><!--l. 324--><p class="noindent" >
</p>
   <h3 class="sectionHead"><span class="titlemark">5   </span> <a 
 id="x1-50005"></a>Resources</h3>
   <div class="thebibliography">
   <p class="bibitem" ><span class="biblabel">
 [1]<span class="bibsp">   </span></span><a 
 id="Xbosi2003intro"></a>M. Bosi and R.E. Goldberd.  <a 
href="https://last.hit.bme.hu/download/vidtechlab/fcc/literature/audio/audio_coding_standards_book.pdf" ><span 
class="ecti-1000">Introduction to Digital Audio Coding and</span>
   <span 
class="ecti-1000">Standards</span></a>. Kluwer Academic Publishers, 2003.
   </p>
   <p class="bibitem" ><span class="biblabel">
 [2]<span class="bibsp">   </span></span><a 
 id="Xthinkstats"></a>A.B. Downey.  <a 
href="https://greenteapress.com/thinkstats/thinkstats.pdf" ><span 
class="ecti-1000">Think Stats Probability and Statistics for Programmers</span></a>.
   O’Reilly, 2011.
   </p>
   <p class="bibitem" ><span class="biblabel">
 [3]<span class="bibsp">   </span></span><a 
 id="Xsayood2017introduction"></a>K. Sayood. <a 
href="http://rahilshaikh.weebly.com/uploads/1/1/6/3/11635894/data_compression.pdf" ><span 
class="ecti-1000">Introduction to data compression</span></a>. Morgan Kaufmann, 2017.
   </p>
   <p class="bibitem" ><span class="biblabel">
 [4]<span class="bibsp">   </span></span><a 
 id="X2006.sweldens"></a>W. Sweldens.   <a 
href="http://cm.bell-labs.com/who/wim/papers/lift1.pdf" >The  Liﬁng  Scheme:  A  Custom-Desing  Constuction  of
   Biorthogonal  Wavelets</a>.   <span 
class="ecti-1000">Applied and Computational Harmonic Analysis</span>,
   3(2):186–200, 1996.
                                                                  

                                                                  
   </p>
   <p class="bibitem" ><span class="biblabel">
 [5]<span class="bibsp">   </span></span><a 
 id="Xvetterli1995wavelets"></a>M. Vetterli   and   J. Kovacevic.      <a 
href="http://waveletsandsubbandcoding.org/Repository/VetterliKovacevic95_Manuscript.pdf" ><span 
class="ecti-1000">Wavelets  and  Subband  Coding</span></a>.
   Prentice-hall, 1995.
</p>
   </div>
<a 
 id="Q1-1-6"></a>
    
</body> 
</html>
                                                                  


