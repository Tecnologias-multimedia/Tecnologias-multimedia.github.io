<!DOCTYPE html> 
<html> 
<head> <title>TecnologÃŋas Multimedia - Study Guide - Milestone 12: Temporal decorrelation
in audio signals</title> 
<meta charset="UTF-8" /> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)" /> 
<link rel="stylesheet" type="text/css" href="index.css" /> 
<script type="text/javascript" 
src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" 
></script> 
<style type="text/css"> 
.MathJax_MathML {text-indent: 0;} 
</style> 
</head><body 
>
   <div class="maketitle">
                                                                  

                                                                  
                                                                  

                                                                  

<h2 class="titleHead"><a 
href="https://www.ual.es/estudios/grados/presentacion/plandeestudios/asignatura/4015/40154321?idioma=zh_CN" >Tecnologías Multimedia</a> - Study Guide -
Milestone 12: Temporal decorrelation in audio
signals</h2>
 <div class="author" ><a 
href="https://cms.ual.es/UAL/personas/persona.htm?id=515256515553484875" ><span 
class="ecrm-1200">Vicente Gonz</span><span 
class="ecrm-1200">á</span><span 
class="ecrm-1200">lez Ruiz</span></a> <span 
class="ecrm-1200">- </span><a 
href="https://cms.ual.es/UAL/universidad/departamentos/informatica/index.htm" ><span 
class="ecrm-1200">Depto Inform</span><span 
class="ecrm-1200">á</span><span 
class="ecrm-1200">tica</span></a> <span 
class="ecrm-1200">- </span><a 
href="https://www.ual.es" ><span 
class="ecrm-1200">UAL</span></a></div><br />
<div class="date" ><span 
class="ecrm-1200">December 15, 2020</span></div>
   </div>
   <h3 class="sectionHead"><span class="titlemark">1   </span> <a 
 id="x1-10001"></a>Description</h3>
<!--l. 7--><p class="noindent" >
</p>
   <h4 class="subsectionHead"><span class="titlemark">1.1   </span> <a 
 id="x1-20001.1"></a>About temporal redundancy in audio</h4>
<!--l. 8--><p class="noindent" >After exploiting the spatial (stereo) redundancy in the previous
milestone, the next natural step in the development of InterCom is
to remove the temporal redundancy that can be found inside of each
subband<span class="footnote-mark"><a 
href="index2.html#fn1x0"><sup class="textsuperscript">1</sup></a></span><a 
 id="x1-2001f1"></a> .
As it can be seen in this <a 
href="https://github.com/Tecnologias-multimedia/intercom/blob/master/docs/audio_viewer.ipynb" >notebook</a>, most audio signals show “patterns” of samples
that tends to repeat, especially locally. Another clear source of temporal
redundancy is that the neighbor audio samples usually show similar amplitude
values.
</p><!--l. 22--><p class="indent" >   There are several techniques that can be used for removing the temporal
redundancy of a sequence of audio. One of the most straightforward is <a 
href="https://en.wikipedia.org/wiki/Differential_pulse-code_modulation" >Diﬀerential
Pulse Code Modulation (DPCM) <span class="cite">[<a 
href="#Xsayood2017introduction">1</a>]</span></a>. However, there are more eﬃcient decorrelation
algorithms based on <a 
href="https://en.wikipedia.org/wiki/Transform_coding" >transform coding</a>, such as the used in the previous milestone and
                                                                  

                                                                  
in this one.
</p><!--l. 33--><p class="indent" >   Transform coding is based on the idea that we can decompose (we can generate a
decomposition from) the input signal into a set of subbands, and if the used ﬁlters
are the adecuate ones for removing the temporal redundancy, we can achieve a high
transform <a 
href="https://en.wikipedia.org/wiki/Coding_gain" >coding gain</a>, accumulating most of the signal energy (and presumably most
of the information) in a small number of subbands. When this happens,
the quantization of the subbands will remove basically the least signiﬁcant
information (usually <a 
href="https://en.wikipedia.org/wiki/Noise_(electronics)" >electronic noise</a>), allowing better compression ratios
than those in which we apply the same quantization process to the original
samples.<span class="footnote-mark"><a 
href="index3.html#fn2x0"><sup class="textsuperscript">2</sup></a></span><a 
 id="x1-2002f2"></a> 
</p>
   <hr class="figure" /><div class="figure" 
>
                                                                  

                                                                  
<a 
 id="x1-2003r1"></a>
                                                                  

                                                                  
<!--l. 51--><p class="noindent" ><div style="text-align:center;"> <img width=500 src="graphics/PRFB.svg" /> </div> 
<a 
 id="x1-2004"></a>
<br /> </p><div class="caption" 
><span class="id">Figure 1: </span><span  
class="content">A 2-channels PRFB (Perfect Reconstruction Filter Bank).</span></div><!--tex4ht:label?: x1-2003r1 -->
                                                                  

                                                                  
   </div><hr class="endfigure" />
   <h4 class="subsectionHead"><span class="titlemark">1.2   </span> <a 
 id="x1-30001.2"></a>Transform and subband coding</h4>
<!--l. 58--><p class="noindent" >The name that has been given to the previous process is
<a 
href="https://en.wikipedia.org/wiki/Sub-band_coding" >subband coding</a>. In this context, our analysis transform matrix
<!--l. 60--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>K</mi></math>
(see the previous milestone) represents the taps of a 2-channels analysis
<a 
href="https://en.wikipedia.org/wiki/Filter_bank" >Filter Bank (FB)</a> <span class="cite">[<a 
href="#Xvetterli1995wavelets">3</a>]</span>, and the forward transform is in fact “descomposing”
<!--l. 64--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>x</mi></math> into two
subbands <!--l. 64--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>w</mi></mrow><mrow 
><mn>0</mn></mrow></msub 
></math>
and <!--l. 64--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>w</mi></mrow><mrow 
><mn>1</mn></mrow></msub 
></math> (see
the Figure <a 
href="#x1-2003r1">1<!--tex4ht:ref: fig:PRFB --></a>, and this <a 
href="https://github.com/Tecnologias-multimedia/intercom/blob/master/docs/PRFB.ipynb" >notebook</a>). On the other hand, the synthesis transform matrix
<!--l. 67--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msup><mrow 
><mi 
>K</mi></mrow><mrow 
><mo 
class="MathClass-bin">−</mo><mn>1</mn></mrow></msup 
></math>
denotes the taps of the corresponding synthesis FB that allows to recover
<!--l. 68--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>x</mi></math>.
</p><!--l. 71--><p class="indent" >   Let’s suppose now that the ﬁlters (represented by the taps of)
<!--l. 71--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>K</mi></mrow><mrow 
><mn>0</mn></mrow></msub 
></math> and
<!--l. 72--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>K</mi></mrow><mrow 
><mn>1</mn></mrow></msub 
></math> are applied to
the input signal <!--l. 72--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>x</mi></math>
(now a sequence of <!--l. 72--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>N</mi></math>
samples) using a <a 
href="https://en.wikipedia.org/wiki/Kernel_(image_processing)" >convolution</a> (without splitting
<!--l. 75--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>x</mi></math>
into blocks). Let’s also suppose (as happens in the MST) that
<!--l. 76--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>K</mi></mrow><mrow 
><mn>0</mn></mrow></msub 
></math> is a low-pass ﬁlter and
<!--l. 76--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>K</mi></mrow><mrow 
><mn>1</mn></mrow></msub 
></math> is a high-pass ﬁlter, and
that the <a 
href="https://en.wikipedia.org/wiki/Filter_(signal_processing)#The_transfer_function" >transfer function</a><span class="footnote-mark"><a 
href="index4.html#fn3x0"><sup class="textsuperscript">3</sup></a></span><a 
 id="x1-3001f3"></a> 
of both ﬁlters <a 
href="https://en.wikipedia.org/wiki/Filter_bank#Perfect_reconstruction_filter_banks" >are one the inverse of the other</a>. Under these assumptions, the complete
(analysis/synthesis) transform is called a (2-channels) <a 
href="https://en.wikipedia.org/wiki/Filter_bank#Perfect_reconstruction_filter_banks" >Perfect Reconstruction Filter Bank
(PRFB)</a>, and <!--l. 86--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>x</mi></math>
can be recovered (perfectly) from a subsampled version (in this case <a 
href="https://en.wikipedia.org/wiki/Downsampling_(signal_processing)" >decimating</a> by 2)
of <!--l. 89--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>w</mi></mrow><mrow 
><mn>0</mn></mrow></msub 
></math>
and <!--l. 89--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>w</mi></mrow><mrow 
><mn>1</mn></mrow></msub 
></math>
(see the <a 
href="https://github.com/Tecnologias-multimedia/intercom/blob/master/docs/PRFB.ipynb" >notebook</a>). Notice that this subsampling is possible because the
<a 
href="https://en.wikipedia.org/wiki/Aliasing" >aliasing</a><span class="footnote-mark"><a 
href="index5.html#fn4x0"><sup class="textsuperscript">4</sup></a></span><a 
 id="x1-3002f4"></a> 
generated in the low-pass subband is compensated by the aliasing generated
in the high-pass subband. To achieve this, the frequency response of
                                                                  

                                                                  
<!--l. 100--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>K</mi></mrow><mrow 
><mn>0</mn></mrow></msub 
></math>
must be equal to the mirror frequency response of
<!--l. 101--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>K</mi></mrow><mrow 
><mn>1</mn></mrow></msub 
></math>,
and obviously, both ﬁlters must have the same bandwidth <span class="cite">[<a 
href="#Xsayood2017introduction">1</a>]</span>. When
<!--l. 102--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>K</mi></mrow><mrow 
><mn>1</mn></mrow></msub 
></math> and
<!--l. 102--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>K</mi></mrow><mrow 
><mn>2</mn></mrow></msub 
></math> are
mirror ﬁlters they form a <a 
href="https://en.wikipedia.org/wiki/Quadrature_mirror_filter" >Quadrature Mirror Filters Bank (QMF)</a>.
</p>
   <h4 class="subsectionHead"><span class="titlemark">1.3   </span> <a 
 id="x1-40001.3"></a>Multichannel ﬁlter banks and psychoacoustic frequency resolution</h4>
<!--l. 109--><p class="noindent" >Using the suitable ﬁlters, it is possible to build
<!--l. 109--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>M</mi></math>-channels
PRFBs.<span class="footnote-mark"><a 
href="index6.html#fn5x0"><sup class="textsuperscript">5</sup></a></span><a 
 id="x1-4001f5"></a> 
These ﬁlters can analyze (and synthesize) the signal
<!--l. 113--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>x</mi></math>,
decomposing it in (<a 
href="https://en.wikipedia.org/wiki/Low-pass_filter#Ideal_and_real_filters" >almost for sure</a>) overlaping frequency subbands with diﬀerent
bandwidth. The question here is to know how many ﬁlters should be used and what
<a 
href="https://en.wikipedia.org/wiki/Band-pass_filter" >pass-band</a> width should they have. At this design point, we must also consider
that the accuracy of the <a 
href="https://en.wikipedia.org/wiki/Psychoacoustics" >humman perception of the sound</a> depends on the
frequency: (as it can be seen in this <a 
href="https://github.com/Tecnologias-multimedia/intercom/blob/master/docs/frequency_resolution.ipynb" >notebook</a>) we are more sensitive to
frequency variations when the frequency of the sound is low. This fact is
related with the way in which the <a 
href="https://en.wikipedia.org/wiki/Critical_band" >critical bands</a> are distributed in <a 
href="https://en.wikipedia.org/wiki/Bark_scale" >the bark
scale</a>.
</p>
   <h4 class="subsectionHead"><span class="titlemark">1.4   </span> <a 
 id="x1-50001.4"></a>The Discrete Wavelet Transform</h4>
<!--l. 132--><p class="noindent" >As it can be seen, the bark scale divides the audible spectrum into 24 subband of (a
priori) “whimsical” bandwidths. However, it’s clear that a <a 
href="https://en.wikipedia.org/wiki/Octave_band" >dyadic partition of the
spectrum</a> ﬁts better than <a 
href="https://en.wikipedia.org/wiki/Wavelet_transform#Principle" >a lineal partition</a>. Considering this reason, from all
the families of transforms designed to date, the most suitable one, from a
frequency partitioning point of view, is the Discrete Wavelet Transform
(DWT).
</p><!--l. 142--><p class="indent" >   The DWT has also other interesting features:
     </p><ol  class="enumerate1" >
     <li 
  class="enumerate" id="x1-5002x1">It is <a 
href="https://en.wikipedia.org/wiki/Discrete_wavelet_transform#Time_complexity" >fast (<!--l. 146--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>O</mi><mrow ><mo 
class="MathClass-open">(</mo><mrow><mi 
>N</mi></mrow><mo 
class="MathClass-close">)</mo></mrow></math>,
     where <!--l. 146--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>N</mi></math>
     is the number of “transformed” samples)</a>.
                                                                  

                                                                  
     </li>
     <li 
  class="enumerate" id="x1-5004x2">It can represent eﬃcienty <a 
href="https://en.wikipedia.org/wiki/Transient_(oscillation)" >transient</a> signals, which can happen frequently
     in audio.
     </li>
     <li 
  class="enumerate" id="x1-5006x3">Although we are not going to take advantage of the following characteristic
     (for now), one of the most interesting features of the DWT is that it can
     used to ﬁnd a <a 
href="https://en.wikipedia.org/wiki/Multiresolution_analysis" >multiresolution representation</a> of the signal.</li></ol>
   <hr class="figure" /><div class="figure" 
>
                                                                  

                                                                  
<a 
 id="x1-5007r2"></a>
                                                                  

                                                                  
<!--l. 159--><p class="noindent" ><div style="text-align:center;"> <img width=1000 src="graphics/cascade.svg" /> </div> 
<a 
 id="x1-5008"></a>
<br /> </p><div class="caption" 
><span class="id">Figure 2: </span><span  
class="content">A dyadic 2-levels cascade of PRFBs.</span></div><!--tex4ht:label?: x1-5007r1 -->
                                                                  

                                                                  
   </div><hr class="endfigure" />
   <h4 class="subsectionHead"><span class="titlemark">1.5   </span> <a 
 id="x1-60001.5"></a>Implementation of the DWT</h4>
<!--l. 166--><p class="noindent" >The DWT can be implemented in diﬀerent ways:
     </p><ol  class="enumerate1" >
     <li 
  class="enumerate" id="x1-6002x1">Deﬁning the transform matrix <!--l. 168--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>K</mi></math>
     (see these <a 
href="https://cseweb.ucsd.edu/classes/fa17/cse166-a/lec13.pdf" >slides</a>) and computing vector-matrix multiplications, which requires
     a calculation time proportional to <!--l. 171--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>O</mi><mrow ><mo 
class="MathClass-open">(</mo><mrow><msup><mrow 
><mi 
>N</mi></mrow><mrow 
><mn>2</mn></mrow></msup 
></mrow><mo 
class="MathClass-close">)</mo></mrow></math>.
     However, the main problem of this type of implementation is generated by
     the amount of memory that <!--l. 173--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>K</mi></math>
     requires, that is proportional to <!--l. 173--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msup><mrow 
><mi 
>N</mi></mrow><mrow 
><mn>2</mn></mrow></msup 
></math>.
     </li>
     <li 
  class="enumerate" id="x1-6004x2"><a 
href="https://en.wikipedia.org/wiki/Discrete_wavelet_transform#Cascading_and_filter_banks" >Cascading PRFBs</a> (see the Figure <a 
href="#x1-5007r2">2<!--tex4ht:ref: fig:cascade --></a>). Considering that the <a 
href="https://en.wikipedia.org/wiki/Convolution" >convolution</a> is
     a <!--l. 178--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>O</mi><mrow ><mo 
class="MathClass-open">(</mo><mrow><mi 
>N</mi><msub><mrow 
><mi class="qopname">log</mi><mo> &ApplyFunction;<!--FUNCTION APPLICATION--> </mo><!--nolimits--></mrow><mrow 
><mn>2</mn></mrow></msub 
><mi 
>N</mi></mrow><mo 
class="MathClass-close">)</mo></mrow></math>
     operation (if it is <a 
href="https://en.wikipedia.org/wiki/Convolution_theorem" >implemented in the frequency domain</a>), and that the
     number of levels in the cascade is generally small (5 for example), this
     implementation is faster than the based in vector-matrix arithmetic. And
     most importantly, we don’t need to store <!--l. 183--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>K</mi></math>,
     but only the taps of the ﬁlters that in a software implementation of a
     cascade can be as small as the number of diﬀerent ﬁlters.<span class="footnote-mark"><a 
href="index7.html#fn6x0"><sup class="textsuperscript">6</sup></a></span><a 
 id="x1-6005f6"></a> 
     </li>
     <li 
  class="enumerate" id="x1-6007x3">Using <a 
href="https://en.wikipedia.org/wiki/Lifting_scheme" >lifting</a> <span class="cite">[<a 
href="#Xsweldens1997building">2</a>]</span>, which provides an extra speed-up factor of 2 compared
     to the FB implementation. DWTs implemented with lifting do not need
     to downsample and upsample the subbands, an operation that is wasting
     the calculus of half of the coeﬃcients at each level of the cascade.</li></ol>
<!--l. 196--><p class="noindent" >
</p>
   <h4 class="subsectionHead"><span class="titlemark">1.6   </span> <a 
 id="x1-70001.6"></a>Example of a DWT using the MST ﬁlters</h4>
<!--l. 198--><p class="noindent" >In order to clarify the previously introduced concepts, let’s build a DWT using the
MST ﬁlters and lifting.
</p><!--l. 201--><p class="indent" >
     </p><ol  class="enumerate1" >
     <li 
  class="enumerate" id="x1-7002x1">Lifting is based on the concept of dyadic <a 
href="https://en.wikipedia.org/wiki/Multiresolution_analysis" >multiresolution analysis</a> of
     the signals (and also with the so called <a 
href="https://en.wikipedia.org/wiki/Polyphase_matrix" >polyphase representation</a> of
     signals). In order to do that, we can rewrite the MST ﬁlter equations
     (<!--l. 207--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>K</mi></mrow><mrow 
><mn>0</mn></mrow></msub 
></math> and
     <!--l. 207--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>K</mi></mrow><mrow 
><mn>1</mn></mrow></msub 
></math>)
     as <table class="equation"><tr><td> <a 
 id="x1-7003r1"></a>
                                                                  

                                                                  
     <!--l. 208--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
 <mtable  align="axis" style=""  
equalrows="false" columnlines="none none" equalcolumns="false" class="array"> <mtr><mtd 
class="array"  columnalign="right">  <msubsup><mrow 
><mi 
>l</mi></mrow><mrow 
><mi 
>i</mi></mrow><mrow 
><mn>1</mn></mrow></msubsup 
>  </mtd><mtd 
class="array"  columnalign="center">   <mo 
class="MathClass-rel">=</mo> </mtd><mtd 
class="array"  columnalign="left">  <msub><mrow 
><mi 
>x</mi></mrow><mrow 
><mn>2</mn><mi 
>i</mi></mrow></msub 
> <mo 
class="MathClass-bin">+</mo> <msub><mrow 
><mi 
>x</mi></mrow><mrow 
><mn>2</mn><mi 
>i</mi><mo 
class="MathClass-bin">+</mo><mn>1</mn></mrow></msub 
>   </mtd>
</mtr>  <mtr><mtd 
class="array"  columnalign="right">  <msubsup><mrow 
><mi 
>h</mi></mrow><mrow 
><mi 
>i</mi></mrow><mrow 
><mn>1</mn></mrow></msubsup 
>  </mtd><mtd 
class="array"  columnalign="center">   <mo 
class="MathClass-rel">=</mo> </mtd><mtd 
class="array"  columnalign="left">  <msub><mrow 
><mi 
>x</mi></mrow><mrow 
><mn>2</mn><mi 
>i</mi><mo 
class="MathClass-bin">+</mo><mn>1</mn></mrow></msub 
> <mo 
class="MathClass-bin">−</mo> <msub><mrow 
><mi 
>x</mi></mrow><mrow 
><mn>2</mn><mi 
>i</mi></mrow></msub 
><mo 
class="MathClass-punc">,</mo> </mtd></mtr><!--rcl--></mtable>
</math></td><td class="eq-no">(1)</td></tr></table>
     <!--l. 215--><p class="noindent" >where the <!--l. 215--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>s</mi></math>-th
     subband <!--l. 215--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msup><mrow 
><mi 
>z</mi></mrow><mrow 
><mi 
>s</mi></mrow></msup 
> <mo 
class="MathClass-rel">=</mo> <mrow ><mo 
class="MathClass-open">{</mo><mrow><msubsup><mrow 
><mi 
>z</mi></mrow><mrow 
><mi 
>i</mi></mrow><mrow 
><mi 
>s</mi></mrow></msubsup 
><mspace width="0.33em" class="nbsp" /><mo 
class="MathClass-rel">|</mo><mspace width="0.33em" class="nbsp" /><mn>0</mn> <mo 
class="MathClass-rel">≤</mo> <mi 
>i</mi> <mo 
class="MathClass-rel">≤</mo> <msup><mrow 
><mn>2</mn></mrow><mrow 
><mi 
>n</mi><mo 
class="MathClass-bin">−</mo><mi 
>s</mi></mrow></msup 
></mrow><mo 
class="MathClass-close">}</mo></mrow></math>,
     <!--l. 215--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msup><mrow 
><mn>2</mn></mrow><mrow 
><mi 
>n</mi></mrow></msup 
> <mo 
class="MathClass-rel">=</mo> <mi 
>N</mi></math> is the number of
     samples in <!--l. 216--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>x</mi></math>, and
     by deﬁnition, <!--l. 216--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msup><mrow 
><mi 
>l</mi></mrow><mrow 
><mn>0</mn></mrow></msup 
> <mo 
class="MathClass-rel">=</mo> <mi 
>x</mi></math>,
     the original resolution level of the signal. The subbands
     <!--l. 217--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msup><mrow 
><mi 
>l</mi></mrow><mrow 
><mn>1</mn></mrow></msup 
></math> and
     <!--l. 217--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msup><mrow 
><mi 
>h</mi></mrow><mrow 
><mn>1</mn></mrow></msup 
></math>
     computed by Eq. <a 
href="#x1-7003r1">1<!--tex4ht:ref: eq:1dwt --></a> are the same than the decimated subbands computed by a
     1-levels PRFB (based on that ﬁlters), and we say, therefore, that Eq. <a 
href="#x1-7003r1">1<!--tex4ht:ref: eq:1dwt --></a>
     computes the 1-levels DWT.
     </p><!--l. 222--><p class="noindent" >Based on the 1-levels DWT, we deﬁne the 2-levels DWT as </p><table class="equation"><tr><td> <a 
 id="x1-7004r2"></a>
     <!--l. 223--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
 <mtable  align="axis" style=""  
equalrows="false" columnlines="none none" equalcolumns="false" class="array"> <mtr><mtd 
class="array"  columnalign="right">  <msubsup><mrow 
><mi 
>l</mi></mrow><mrow 
><mi 
>i</mi></mrow><mrow 
><mn>2</mn></mrow></msubsup 
>  </mtd><mtd 
class="array"  columnalign="center">   <mo 
class="MathClass-rel">=</mo> </mtd><mtd 
class="array"  columnalign="left">  <msubsup><mrow 
><mi 
>l</mi></mrow><mrow 
><mn>2</mn><mi 
>i</mi></mrow><mrow 
><mn>1</mn></mrow></msubsup 
> <mo 
class="MathClass-bin">+</mo> <msubsup><mrow 
><mi 
>l</mi></mrow><mrow 
><mn>2</mn><mi 
>i</mi><mo 
class="MathClass-bin">+</mo><mn>1</mn></mrow><mrow 
><mn>1</mn></mrow></msubsup 
>   </mtd>
</mtr>  <mtr><mtd 
class="array"  columnalign="right">  <msubsup><mrow 
><mi 
>h</mi></mrow><mrow 
><mi 
>i</mi></mrow><mrow 
><mn>2</mn></mrow></msubsup 
>  </mtd><mtd 
class="array"  columnalign="center">   <mo 
class="MathClass-rel">=</mo> </mtd><mtd 
class="array"  columnalign="left">  <msubsup><mrow 
><mi 
>l</mi></mrow><mrow 
><mn>2</mn><mi 
>i</mi><mo 
class="MathClass-bin">+</mo><mn>1</mn></mrow><mrow 
><mn>1</mn></mrow></msubsup 
> <mo 
class="MathClass-bin">−</mo> <msubsup><mrow 
><mi 
>l</mi></mrow><mrow 
><mn>2</mn><mi 
>i</mi></mrow><mrow 
><mn>1</mn></mrow></msubsup 
><mo 
class="MathClass-punc">,</mo> </mtd></mtr><!--rcl--></mtable>
</math></td><td class="eq-no">(2)</td></tr></table>
     <!--l. 230--><p class="noindent" >that, as we can see, uses as input the output of Eq. <a 
href="#x1-7003r1">1<!--tex4ht:ref: eq:1dwt --></a>.
     </p><!--l. 232--><p class="noindent" >In general, for a <!--l. 232--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>s</mi></math>-levels
     DWT, we get </p><table class="equation"><tr><td> <a 
 id="x1-7005r3"></a>
                                                                  

                                                                  
     <!--l. 233--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
 <mtable  align="axis" style=""  
equalrows="false" columnlines="none none" equalcolumns="false" class="array"> <mtr><mtd 
class="array"  columnalign="right">  <msubsup><mrow 
><mi 
>l</mi></mrow><mrow 
><mi 
>i</mi></mrow><mrow 
><mi 
>s</mi></mrow></msubsup 
>  </mtd><mtd 
class="array"  columnalign="center">   <mo 
class="MathClass-rel">=</mo> </mtd><mtd 
class="array"  columnalign="left">  <msubsup><mrow 
><mi 
>l</mi></mrow><mrow 
><mn>2</mn><mi 
>i</mi></mrow><mrow 
><mi 
>s</mi><mo 
class="MathClass-bin">−</mo><mn>1</mn></mrow></msubsup 
> <mo 
class="MathClass-bin">+</mo> <msubsup><mrow 
><mi 
>l</mi></mrow><mrow 
><mn>2</mn><mi 
>i</mi><mo 
class="MathClass-bin">+</mo><mn>1</mn></mrow><mrow 
><mi 
>s</mi><mo 
class="MathClass-bin">−</mo><mn>1</mn></mrow></msubsup 
>   </mtd>
</mtr>  <mtr><mtd 
class="array"  columnalign="right">  <msubsup><mrow 
><mi 
>h</mi></mrow><mrow 
><mi 
>i</mi></mrow><mrow 
><mi 
>s</mi></mrow></msubsup 
>  </mtd><mtd 
class="array"  columnalign="center">   <mo 
class="MathClass-rel">=</mo> </mtd><mtd 
class="array"  columnalign="left">  <msubsup><mrow 
><mi 
>l</mi></mrow><mrow 
><mn>2</mn><mi 
>i</mi><mo 
class="MathClass-bin">+</mo><mn>1</mn></mrow><mrow 
><mi 
>s</mi><mo 
class="MathClass-bin">−</mo><mn>1</mn></mrow></msubsup 
> <mo 
class="MathClass-bin">−</mo> <msubsup><mrow 
><mi 
>l</mi></mrow><mrow 
><mn>2</mn><mi 
>i</mi></mrow><mrow 
><mi 
>s</mi><mo 
class="MathClass-bin">−</mo><mn>1</mn></mrow></msubsup 
><mo 
class="MathClass-punc">.</mo> </mtd></mtr><!--rcl--></mtable>
</math></td><td class="eq-no">(3)</td></tr></table>
     <!--l. 241--><p class="noindent" >The <!--l. 241--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>s</mi></math>-levels DWT splits
     the signal spectrum in <!--l. 241--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>s</mi> <mo 
class="MathClass-bin">+</mo> <mn>1</mn></math>
     subbands. If <!--l. 242--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>s</mi> <mo 
class="MathClass-rel">=</mo> <mi 
>n</mi></math>,
     we have the spectrum partition </p><table class="equation-star"><tr><td>
     <!--l. 243--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
          <mo 
class="MathClass-rel">|</mo><msubsup><mrow 
><mi 
>l</mi></mrow><mrow 
><mn>0</mn></mrow><mrow 
><mi 
>s</mi></mrow></msubsup 
><mo 
class="MathClass-rel">|</mo><msubsup><mrow 
><mi 
>h</mi></mrow><mrow 
>
<mn>0</mn></mrow><mrow 
><mi 
>s</mi></mrow></msubsup 
><mo 
class="MathClass-rel">|</mo><msubsup><mrow 
><mi 
>h</mi></mrow><mrow 
>
<mn>0</mn></mrow><mrow 
><mi 
>s</mi><mo 
class="MathClass-bin">−</mo><mn>1</mn></mrow></msubsup 
><msubsup><mrow 
><mi 
>h</mi></mrow><mrow 
>
<mn>1</mn></mrow><mrow 
><mi 
>s</mi><mo 
class="MathClass-bin">−</mo><mn>1</mn></mrow></msubsup 
><mo 
class="MathClass-rel">|</mo><msubsup><mrow 
><mi 
>h</mi></mrow><mrow 
>
<mn>0</mn></mrow><mrow 
><mi 
>s</mi><mo 
class="MathClass-bin">−</mo><mn>2</mn></mrow></msubsup 
><msubsup><mrow 
><mi 
>h</mi></mrow><mrow 
>
<mn>1</mn></mrow><mrow 
><mi 
>s</mi><mo 
class="MathClass-bin">−</mo><mn>2</mn></mrow></msubsup 
><msubsup><mrow 
><mi 
>h</mi></mrow><mrow 
>
<mn>2</mn></mrow><mrow 
><mi 
>s</mi><mo 
class="MathClass-bin">−</mo><mn>2</mn></mrow></msubsup 
><msubsup><mrow 
><mi 
>h</mi></mrow><mrow 
>
<mn>3</mn></mrow><mrow 
><mi 
>s</mi><mo 
class="MathClass-bin">−</mo><mn>2</mn></mrow></msubsup 
><mo 
class="MathClass-rel">|</mo><mo 
class="MathClass-rel">⋯</mo><mo 
class="MathClass-rel">|</mo><msubsup><mrow 
><mi 
>h</mi></mrow><mrow 
>
<mn>0</mn></mrow><mrow 
><mn>1</mn></mrow></msubsup 
><msubsup><mrow 
><mi 
>h</mi></mrow><mrow 
>
<mn>1</mn></mrow><mrow 
><mn>1</mn></mrow></msubsup 
><mo 
class="MathClass-rel">⋯</mo><msubsup><mrow 
><mi 
>h</mi></mrow><mrow 
><msup><mrow 
>
<mn>2</mn></mrow><mrow 
><mi 
>n</mi><mo 
class="MathClass-bin">−</mo><mn>1</mn></mrow></msup 
><mo 
class="MathClass-bin">−</mo><mn>1</mn></mrow><mrow 
><mn>1</mn></mrow></msubsup 
><mo 
class="MathClass-rel">|</mo><mo 
class="MathClass-punc">,</mo>
</math></td></tr></table>
     <!--l. 246--><p class="noindent" >where<span class="footnote-mark"><a 
href="index8.html#fn7x0"><sup class="textsuperscript">7</sup></a></span><a 
 id="x1-7006f7"></a> 
     it holds that </p><table class="equation"><tr><td> <a 
 id="x1-7007r4"></a>
     <!--l. 249--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                                     <mn>1</mn> <mo 
class="MathClass-bin">+</mo><munderover accentunder="false" accent="false"><mrow  
><mo  
> ∑</mo>
  </mrow><mrow 
><mi 
>j</mi><mo 
class="MathClass-rel">=</mo><mn>1</mn></mrow><mrow 
><mi 
>s</mi></mrow></munderover 
><msup><mrow 
><mn>2</mn></mrow><mrow 
><mi 
>j</mi><mo 
class="MathClass-bin">−</mo><mn>1</mn></mrow></msup 
> <mo 
class="MathClass-rel">=</mo> <msup><mrow 
><mn>2</mn></mrow><mrow 
><mi 
>n</mi></mrow></msup 
><mo 
class="MathClass-punc">.</mo>
</math></td><td class="eq-no">(4)</td></tr></table>
     </li>
     <li 
  class="enumerate" id="x1-7009x2">DWT transforms perform a number of lifting steps, each one with 2
     (sub)steps:
                                                                  

                                                                  
         <ol  class="enumerate2" >
         <li 
  class="enumerate" id="x1-7011x1">Predict step: compute the <!--l. 256--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>h</mi></math>
         subbands as a prediction error, that should be minimized, between
         the even samples (the values to predict) and the odd samples
         (the values used to predict). For the MST ﬁlters, we have that <table class="equation"><tr><td>
         <a 
 id="x1-7012r5"></a>
         <!--l. 260--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                                    <msubsup><mrow 
><mi 
>h</mi></mrow><mrow 
><mi 
>i</mi></mrow><mrow 
><mi 
>s</mi></mrow></msubsup 
> <mo 
class="MathClass-rel">=</mo> <msubsup><mrow 
><mi 
>l</mi></mrow><mrow 
>
<mn>2</mn><mi 
>i</mi><mo 
class="MathClass-bin">+</mo><mn>1</mn></mrow><mrow 
><mi 
>s</mi><mo 
class="MathClass-bin">−</mo><mn>1</mn></mrow></msubsup 
> <mo 
class="MathClass-bin">−</mo> <msubsup><mrow 
><mi 
>l</mi></mrow><mrow 
>
<mn>2</mn><mi 
>i</mi></mrow><mrow 
><mi 
>s</mi><mo 
class="MathClass-bin">−</mo><mn>1</mn></mrow></msubsup 
><mo 
class="MathClass-punc">.</mo>
</math></td><td class="eq-no">(5)</td></tr></table>
         </li>
         <li 
  class="enumerate" id="x1-7014x2">Update step: compute the <!--l. 264--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>l</mi></math>
         subbands considering (only) the even samples and the prediction errors.
         For the MST, we have <table class="equation"><tr><td> <a 
 id="x1-7015r6"></a>
         <!--l. 266--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                                       <msubsup><mrow 
><mi 
>l</mi></mrow><mrow 
><mi 
>i</mi></mrow><mrow 
><mi 
>s</mi></mrow></msubsup 
> <mo 
class="MathClass-rel">=</mo> <mn>2</mn><msubsup><mrow 
><mi 
>l</mi></mrow><mrow 
>
<mn>2</mn><mi 
>i</mi></mrow><mrow 
><mi 
>s</mi><mo 
class="MathClass-bin">−</mo><mn>1</mn></mrow></msubsup 
> <mo 
class="MathClass-bin">+</mo> <msubsup><mrow 
><mi 
>h</mi></mrow><mrow 
>
<mi 
>i</mi></mrow><mrow 
><mi 
>s</mi></mrow></msubsup 
><mo 
class="MathClass-punc">.</mo>
</math></td><td class="eq-no">(6)</td></tr></table>
         </li></ol>
     <!--l. 271--><p class="noindent" >Notice that these steps are invertible: </p><table class="equation"><tr><td> <a 
 id="x1-7016r7"></a>
                                                                  

                                                                  
     <!--l. 272--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
 <mtable  align="axis" style=""  
equalrows="false" columnlines="none none" equalcolumns="false" class="array"> <mtr><mtd 
class="array"  columnalign="right">     <msubsup><mrow 
><mi 
>l</mi></mrow><mrow 
><mn>2</mn><mi 
>i</mi></mrow><mrow 
><mi 
>s</mi><mo 
class="MathClass-bin">−</mo><mn>1</mn></mrow></msubsup 
>  </mtd><mtd 
class="array"  columnalign="center">   <mo 
class="MathClass-rel">=</mo> </mtd><mtd 
class="array"  columnalign="left">  <mfrac><mrow 
><mn>1</mn></mrow> 
<mrow 
><mn>2</mn></mrow></mfrac><mrow ><mo 
class="MathClass-open">(</mo><mrow><msubsup><mrow 
><mi 
>l</mi></mrow><mrow 
><mi 
>i</mi></mrow><mrow 
><mi 
>s</mi></mrow></msubsup 
> <mo 
class="MathClass-bin">−</mo> <msubsup><mrow 
><mi 
>h</mi></mrow><mrow 
>
<mi 
>i</mi></mrow><mrow 
><mi 
>s</mi></mrow></msubsup 
></mrow><mo 
class="MathClass-close">)</mo></mrow>  </mtd>
</mtr>  <mtr><mtd 
class="array"  columnalign="right">  <msubsup><mrow 
><mi 
>l</mi></mrow><mrow 
><mn>2</mn><mi 
>i</mi><mo 
class="MathClass-bin">+</mo><mn>1</mn></mrow><mrow 
><mi 
>s</mi><mo 
class="MathClass-bin">−</mo><mn>1</mn></mrow></msubsup 
>  </mtd><mtd 
class="array"  columnalign="center">   <mo 
class="MathClass-rel">=</mo> </mtd><mtd 
class="array"  columnalign="left">  <msubsup><mrow 
><mi 
>l</mi></mrow><mrow 
><mn>2</mn><mi 
>i</mi></mrow><mrow 
><mi 
>s</mi><mo 
class="MathClass-bin">−</mo><mn>1</mn></mrow></msubsup 
> <mo 
class="MathClass-bin">+</mo> <msubsup><mrow 
><mi 
>h</mi></mrow><mrow 
><mi 
>i</mi></mrow><mrow 
><mi 
>s</mi></mrow></msubsup 
><mo 
class="MathClass-punc">.</mo> </mtd></mtr><!--rcl--></mtable>
</math></td><td class="eq-no">(7)</td></tr></table>
     </li></ol>
<!--l. 281--><p class="noindent" >
</p>
   <h4 class="subsectionHead"><span class="titlemark">1.7   </span> <a 
 id="x1-80001.7"></a>Wavelets and ﬁlter banks</h4>
<!--l. 282--><p class="noindent" >In the context of the wavelet theory <span class="cite">[<span 
class="ecbx-1000">?</span>]</span>, the response of the analysis low-pass ﬁlter
(<!--l. 283--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>K</mi></mrow><mrow 
><mn>0</mn></mrow></msub 
></math>) to the <a 
href="https://en.wikipedia.org/?title=Unit_impulse&redirect=no" >unit
impulse</a><span class="footnote-mark"><a 
href="index9.html#fn8x0"><sup class="textsuperscript">8</sup></a></span><a 
 id="x1-8001f8"></a> 
is known as the scaling function and is usually denoted by
<!--l. 288--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>ϕ</mi></math>, the response of the
analysis high-pass ﬁlter (<!--l. 289--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>K</mi></mrow><mrow 
><mn>1</mn></mrow></msub 
></math>)
is known as the wavelet function and it is usually denoted by
<!--l. 290--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>ψ</mi></math>, the response of the
synthesis low-pass ﬁlter (<!--l. 291--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msubsup><mrow 
><mi 
>K</mi></mrow><mrow 
><mn>0</mn></mrow><mrow 
><mo 
class="MathClass-bin">−</mo><mn>1</mn></mrow></msubsup 
></math>)
is denoted by <!--l. 291--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mover 
accent="true"><mrow 
><mi 
>ϕ</mi></mrow><mo accent="true">̃</mo></mover></math> and the
synthesis high-pass ﬁlter (<!--l. 292--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msubsup><mrow 
><mi 
>K</mi></mrow><mrow 
><mn>1</mn></mrow><mrow 
><mo 
class="MathClass-bin">−</mo><mn>1</mn></mrow></msubsup 
></math>)
is represented by <!--l. 292--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mover 
accent="true"><mrow 
><mi 
>ψ</mi></mrow><mo accent="true">̃</mo></mover></math>.
</p><!--l. 294--><p class="indent" >   For the MST it holds that <!--l. 294--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>ϕ</mi><mo 
class="MathClass-rel">⊥</mo><mi 
>ψ</mi></math>,
that <!--l. 294--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>ϕ</mi> <mo 
class="MathClass-rel">=</mo> <mover 
accent="true"><mrow 
><mi 
>ψ</mi></mrow><mo accent="true">̃</mo></mover></math> and
that <!--l. 295--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>ψ</mi> <mo 
class="MathClass-rel">=</mo> <mover 
accent="true"><mrow 
><mi 
>ϕ</mi></mrow><mo accent="true">̃</mo></mover></math>.
This is true for all orthogonal DWTs. Another important
characteristic of orthogonal DWTs is that the ﬁlters cannot be
symmetric.<span class="footnote-mark"><a 
href="index10.html#fn9x0"><sup class="textsuperscript">9</sup></a></span><a 
 id="x1-8002f9"></a> 
</p>
   <h4 class="subsectionHead"><span class="titlemark">1.8   </span> <a 
 id="x1-90001.8"></a>Example of a DWT using high-order ﬁlters</h4>
<!--l. 304--><p class="noindent" >The previous MST-based DWT is similar to other transforms such as the <a 
href="https://en.wikipedia.org/wiki/Haar_wavelet" >Haar
transform</a>, in which we are using an 1-order predictor for removing the temporal
redundancy. Let’s extend the lifting idea to a prediction of order two. For that, we
deﬁne the predict step as </p><table class="equation"><tr><td> <a 
 id="x1-9001r8"></a>
                                                                  

                                                                  
<!--l. 309--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                 <msubsup><mrow 
><mi 
>h</mi></mrow><mrow 
><mi 
>i</mi></mrow><mrow 
><mi 
>s</mi></mrow></msubsup 
> <mo 
class="MathClass-rel">=</mo> <msubsup><mrow 
><mi 
>l</mi></mrow><mrow 
>
<mn>2</mn><mi 
>i</mi><mo 
class="MathClass-bin">+</mo><mn>1</mn></mrow><mrow 
><mi 
>s</mi><mo 
class="MathClass-bin">−</mo><mn>1</mn></mrow></msubsup 
> <mo 
class="MathClass-bin">−</mo><mfrac><mrow 
><mn>1</mn></mrow> 
<mrow 
><mn>2</mn></mrow></mfrac><mrow ><mo 
class="MathClass-open">(</mo><mrow><msubsup><mrow 
><mi 
>l</mi></mrow><mrow 
><mn>2</mn><mi 
>i</mi></mrow><mrow 
><mi 
>s</mi><mo 
class="MathClass-bin">−</mo><mn>1</mn></mrow></msubsup 
> <mo 
class="MathClass-bin">+</mo> <msubsup><mrow 
><mi 
>l</mi></mrow><mrow 
>
<mn>2</mn><mi 
>i</mi><mo 
class="MathClass-bin">+</mo><mn>2</mn></mrow><mrow 
><mi 
>s</mi><mo 
class="MathClass-bin">−</mo><mn>1</mn></mrow></msubsup 
></mrow><mo 
class="MathClass-close">)</mo></mrow>
</math></td><td class="eq-no">(8)</td></tr></table>
<!--l. 312--><p class="indent" >   and the update step as </p><table class="equation"><tr><td> <a 
 id="x1-9002r9"></a>
<!--l. 313--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                     <msubsup><mrow 
><mi 
>l</mi></mrow><mrow 
><mi 
>i</mi></mrow><mrow 
><mi 
>s</mi></mrow></msubsup 
> <mo 
class="MathClass-rel">=</mo> <msubsup><mrow 
><mi 
>l</mi></mrow><mrow 
>
<mn>2</mn><mi 
>i</mi></mrow><mrow 
><mi 
>s</mi><mo 
class="MathClass-bin">−</mo><mn>1</mn></mrow></msubsup 
> <mo 
class="MathClass-bin">+</mo> <mfrac><mrow 
><mn>1</mn></mrow> 
<mrow 
><mn>4</mn></mrow></mfrac><mrow ><mo 
class="MathClass-open">(</mo><mrow><msubsup><mrow 
><mi 
>h</mi></mrow><mrow 
><mi 
>i</mi><mo 
class="MathClass-bin">−</mo><mn>1</mn></mrow><mrow 
><mi 
>s</mi></mrow></msubsup 
> <mo 
class="MathClass-bin">+</mo> <msubsup><mrow 
><mi 
>h</mi></mrow><mrow 
>
<mi 
>i</mi></mrow><mrow 
><mi 
>s</mi></mrow></msubsup 
></mrow><mo 
class="MathClass-close">)</mo></mrow><mo 
class="MathClass-punc">,</mo>
</math></td><td class="eq-no">(9)</td></tr></table>
<!--l. 316--><p class="indent" >   where the factor 1/4 is used to preserve the energy <span class="cite">[<a 
href="#Xsweldens1997building">2</a>]</span>. This transform is known
as the <a 
href="https://en.wikipedia.org/wiki/Biorthogonal_wavelet" >biorthogonal</a> (2,2) of Cohen-Daubechies-Feauveau, and also as the linear
transform. Biorthogonal ﬁlters can be <a 
href="http://wavelets.pybytes.com/" >easely recognized</a> because they are always
symmetric and because the analysis ﬁlters are diﬀerent to the synthesis ﬁlters
(<!--l. 323--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>ϕ</mi><mo 
class="MathClass-rel">≠</mo><mover 
accent="true"><mrow 
><mi 
>ϕ</mi></mrow><mo accent="true">̃</mo></mover></math> and
<!--l. 323--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>ψ</mi><mo 
class="MathClass-rel">≠</mo><mover 
accent="true"><mrow 
><mi 
>ψ</mi></mrow><mo accent="true">̃</mo></mover></math>).
</p><!--l. 325--><p class="indent" >   Again, the linear transform in invertible by simply reversing the steps: </p><table class="equation"><tr><td>
<a 
 id="x1-9003r10"></a>
<!--l. 327--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
 <mtable  align="axis" style=""  
equalrows="false" columnlines="none none" equalcolumns="false" class="array"> <mtr><mtd 
class="array"  columnalign="right">     <msubsup><mrow 
><mi 
>l</mi></mrow><mrow 
><mn>2</mn><mi 
>i</mi></mrow><mrow 
><mi 
>s</mi><mo 
class="MathClass-bin">−</mo><mn>1</mn></mrow></msubsup 
>  </mtd><mtd 
class="array"  columnalign="center">  <mo 
class="MathClass-rel">=</mo> </mtd><mtd 
class="array"  columnalign="left"> <msubsup><mrow 
><mi 
>l</mi></mrow><mrow 
><mi 
>i</mi></mrow><mrow 
><mi 
>s</mi></mrow></msubsup 
> <mo 
class="MathClass-bin">−</mo><mfrac><mrow 
><mn>1</mn></mrow> 
<mrow 
><mn>4</mn></mrow></mfrac><mrow ><mo 
class="MathClass-open">(</mo><mrow><msubsup><mrow 
><mi 
>h</mi></mrow><mrow 
><mi 
>i</mi><mo 
class="MathClass-bin">−</mo><mn>1</mn></mrow><mrow 
><mi 
>s</mi></mrow></msubsup 
> <mo 
class="MathClass-bin">+</mo> <msubsup><mrow 
><mi 
>h</mi></mrow><mrow 
>
<mi 
>i</mi></mrow><mrow 
><mi 
>s</mi></mrow></msubsup 
></mrow><mo 
class="MathClass-close">)</mo></mrow>          </mtd>
</mtr>  <mtr><mtd 
class="array"  columnalign="right">  <msubsup><mrow 
><mi 
>l</mi></mrow><mrow 
><mn>2</mn><mi 
>i</mi><mo 
class="MathClass-bin">+</mo><mn>1</mn></mrow><mrow 
><mi 
>s</mi><mo 
class="MathClass-bin">−</mo><mn>1</mn></mrow></msubsup 
>  </mtd><mtd 
class="array"  columnalign="center">  <mo 
class="MathClass-rel">=</mo> </mtd><mtd 
class="array"  columnalign="left"> <msubsup><mrow 
><mi 
>h</mi></mrow><mrow 
><mi 
>i</mi></mrow><mrow 
><mi 
>s</mi></mrow></msubsup 
> <mo 
class="MathClass-bin">+</mo> <mfrac><mrow 
><mn>1</mn></mrow> 
<mrow 
><mn>2</mn></mrow></mfrac><mrow ><mo 
class="MathClass-open">(</mo><mrow><msubsup><mrow 
><mi 
>l</mi></mrow><mrow 
><mn>2</mn><mi 
>i</mi></mrow><mrow 
><mi 
>s</mi><mo 
class="MathClass-bin">−</mo><mn>1</mn></mrow></msubsup 
> <mo 
class="MathClass-bin">+</mo> <msubsup><mrow 
><mi 
>l</mi></mrow><mrow 
>
<mn>2</mn><mi 
>i</mi><mo 
class="MathClass-bin">+</mo><mn>2</mn></mrow><mrow 
><mi 
>s</mi><mo 
class="MathClass-bin">−</mo><mn>1</mn></mrow></msubsup 
></mrow><mo 
class="MathClass-close">)</mo></mrow><mo 
class="MathClass-punc">.</mo> </mtd></mtr><!--rcl--></mtable>
</math></td><td class="eq-no">(10)</td></tr></table>
                                                                  

                                                                  
<!--l. 334--><p class="noindent" >
</p>
   <h4 class="subsectionHead"><span class="titlemark">1.9   </span> <a 
 id="x1-100001.9"></a><a 
href="https://en.wikipedia.org/wiki/Lapped_transform" >Lapped transform</a> for minimizing the distortion</h4>
<!--l. 335--><p class="noindent" >A ﬁnal (and important) consideration about transform coding and quantization.
Transform coding implies splitting the signal into chunks, and computing the
transform of each chunk. When the coeﬃcients are quantized, it is possible that
signiﬁcative (and unpleasant) distortions may appear between the border samples of
the chunks (see this <a 
href="https://github.com/Tecnologias-multimedia/intercom/blob/master/docs/quantization_DWT.ipynb" >notebook</a>). One simple solution is to use the last samples of the
<!--l. 342--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>i</mi> <mo 
class="MathClass-bin">−</mo> <mn>1</mn></math>-th chunk and the ﬁrst samples
of the <!--l. 343--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>i</mi> <mo 
class="MathClass-bin">+</mo> <mn>1</mn></math>-chunk for computing
the transform of the <!--l. 344--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>i</mi></math>-th
chunk (notice that this <a 
href="https://en.wikipedia.org/wiki/Lapped_transform" >overlaping</a> does not imply to generate more transform
coeﬃcients, but only to avoid using an artiﬁcial <a 
href="https://pywavelets.readthedocs.io/en/latest/ref/signal-extension-modes.html" >signal extension</a>). The number of
overlaped samples depends on the length of the ﬁlters and the number of levels
<!--l. 350--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>s</mi></math> of the
DWT. This last parameter (the number of levels of the DWT) has also a
high impact on the decorrelation process, but take into consideration that,
depending on the signal, usually happens that it is not worth decomposing
the signal into the maximum number subbands because the increments in
the coding gain can be negligible beyond a number of levels (typically,
<!--l. 356--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mn>5</mn></math>).
</p><!--l. 358--><p class="noindent" >
</p>
   <h3 class="sectionHead"><span class="titlemark">2   </span> <a 
 id="x1-110002"></a>What you have to do?</h3>
<!--l. 360--><p class="noindent" >
     </p><ol  class="enumerate1" >
     <li 
  class="enumerate" id="x1-11002x1">In a module named temporal.py, inherit the class Spatial_decorrelation
     and create a class named Temporal_decorrelation.
     </li>
     <li 
  class="enumerate" id="x1-11004x2">Override the methods pack() and unpack(). In pack() perform a DWT
     decomposition of each channel, and in unpack() perform the inverse transform.
     Use a suitable<span class="footnote-mark"><a 
href="index11.html#fn10x0"><sup class="textsuperscript">10</sup></a></span><a 
 id="x1-11005f10"></a> 
     wavelet from <a 
href="https://pywavelets.readthedocs.io/en/latest/" >PyWavelets</a>. Take also into consideration that the signal
     should  be  processed  using  overlaped  chunks  in  order  to  minimize  the
     discontinuities  of  the  signal  at  the  chunk  boundaries,  when  the  DWT
     coeﬃcients are quantized.
     </li>
     <li 
  class="enumerate" id="x1-11007x3">Has been the <a 
href="https://en.wikipedia.org/wiki/Data_compression_ratio" >compression ratio</a> improved (on <a 
href="https://en.wikipedia.org/wiki/Average" >average</a>)? How much?</li></ol>
                                                                  

                                                                  
<!--l. 379--><p class="noindent" >
</p>
   <h3 class="sectionHead"><span class="titlemark">3   </span> <a 
 id="x1-120003"></a>Timming</h3>
<!--l. 381--><p class="noindent" >This is the ﬁnal milestone. Present your results in the exam time.
</p><!--l. 383--><p class="noindent" >
</p>
   <h3 class="sectionHead"><span class="titlemark">4   </span> <a 
 id="x1-130004"></a>Deliverables</h3>
<!--l. 385--><p class="noindent" >The module temporal.py. Store it at the <a 
href="https://github.com/Tecnologias-multimedia/intercom" >root directory</a> of your InterCom’s
repo.
</p><!--l. 389--><p class="noindent" >
</p>
   <h3 class="sectionHead"><span class="titlemark">5   </span> <a 
 id="x1-140005"></a>Resources</h3>
   <div class="thebibliography">
   <p class="bibitem" ><span class="biblabel">
 [1]<span class="bibsp">   </span></span><a 
 id="Xsayood2017introduction"></a>K. Sayood. <a 
href="http://rahilshaikh.weebly.com/uploads/1/1/6/3/11635894/data_compression.pdf" ><span 
class="ecti-1000">Introduction to data compression</span></a>. Morgan Kaufmann, 2017.
   </p>
   <p class="bibitem" ><span class="biblabel">
 [2]<span class="bibsp">   </span></span><a 
 id="Xsweldens1997building"></a>W. Sweldens and P. Schröder.  <a 
href="https://scholar.google.es/scholar?hl=es&as_sdt=0%2C5&q=building+your+own+wavelets+at+home+1997+Sweldens+Schr%C3%B6der&btnG=" >Building your own wavelets at home</a>.
   <span 
class="ecti-1000">Wavelets in Computer Graphics</span>, 1997.
   </p>
   <p class="bibitem" ><span class="biblabel">
 [3]<span class="bibsp">   </span></span><a 
 id="Xvetterli1995wavelets"></a>M. Vetterli   and   J. Kovacevic.      <a 
href="http://waveletsandsubbandcoding.org/Repository/VetterliKovacevic95_Manuscript.pdf" ><span 
class="ecti-1000">Wavelets  and  Subband  Coding</span></a>.
   Prentice-hall, 1995.
</p>
   </div>
<a 
 id="Q1-1-15"></a>
    
</body> 
</html>
                                                                  


