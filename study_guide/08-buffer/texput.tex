\input{../definitions}
\title{\TM{} - Study Guide - Milestone 8: Buffering for hidding the jitter}

\maketitle

\section{Description}

As we have determined in the previous milestones, we can consider that
the QoE provided by InterCom is inversely proportional to the network
jitter (see Fig.~\ref{fig:timelines}-a). One solution (see
Fig.~\ref{fig:timelines}-b) to this drawback is the use of a
\href{https://en.wikipedia.org/wiki/Random_access}{random access}
\href{https://en.wikipedia.org/wiki/Data_buffer}{buffer} at the
receiver side, where the chunks are stored for a time large enough to
hidde the jitter to the user~\cite{Kurose-Ross}.

\begin{figure}
  \begin{center}
    \myfig{graphics/timelines}{10cm}{1000}
  \end{center}
  \caption{Timelines of two InterCom interactions. On the left, the
    playback is defective because some chunks are lost. On the right,
    the audio rendering is correct because the playback has been
    delayed 2 chunk times (enough for this example).}
  \label{fig:timelines}
\end{figure}

\href{https://en.wikipedia.org/wiki/Jitter#Jitter_buffers}{\emph{Dejitterizing}
  buffers} are typically implemented with a circular buffer structure
(see Fig.~\ref{fig:circular_buffer}). In an ideal situation (as
the depicted in the figure), the number of pending-to-be-played chunks
available in the buffer is half of the number of cells in the buffer,
and the chunks have arrived on time. In this example, the receiver
(where the chunks are buffered) waits for 3 chunks before to start
playing the chunk number 0.\footnote{Implementation tip: in a system
  where for each recorded chunk a chunk must be also played, a delay
  in the playback can be generated by sending zero-chunks to the DAC
  and then, after the delay, start sending the received chunk of
  audio, in the right order.} Notice that the number of cells in the
buffer $2N$ must be the double of the number of the chunks buffered
during the buffering time $N$, in order to hide a $N$ chunk-time
jitter. Notice also that this technique introduces also a $N$
chunk-times delay in the playback.

\begin{figure}
  \begin{tabular}{ccc}
    \vbox{\myfig{graphics/circular_buffer1}{2cm}{200}} & \vbox{\myfig{graphics/circular_buffer2}{2cm}{200}} & \vbox{\myfig{graphics/circular_buffer3}{2cm}{200}} \\
    (a) & (b) & (c)
  \end{tabular}
  \caption{A circular buffer with 6 cells (space for 6 chunks). Up to
    the half of the buffer is occupied (cells in gray) because the
    buffering time is 3 chunk times and 3 chunks (with chunk number 0,
    1 and 2 in the beginning, subfigure (a)) have been received. The
    first chunk to be played is chunk 0 (subfigure (b)). Then, a new
    chunk (chunk number 3) is received and buffered (subfigure (c)).}
  \label{fig:circular_buffer}
\end{figure}

For this new improved InterCom a parameter with the \emph{buffering
  time} must be provided by the users. This value (typically expressed
in miliseconds) should be large enough to hide the network jitter, but
small enough to minimize the end-to-end (user) latency.

The following guidelines have been used to implement the
\emph{buffered} version of InterCom:

\begin{enumerate}
\item The class Minimal
  (\href{https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)}{inherit}
  from) has been inherited (extended) to implement a new class
  Buffering.
\item In the payload of the UDP packets a chunk number has been
  included in order to provide to the receiver the information to
  determine where to store the corresponding chunk in the circular
  buffer. An unsigned integer of 16 bits has been used for
  representing the chunk numbers.
\item It has been taken into consideration that the critical part of
  InterCom (the method \verb|record_send_and_play()|) is a method that
  runs as an
  \href{https://en.wikipedia.org/wiki/Interrupt_handler}{interrup
    handler} that could be called each time a new chunk is available
  in the ADC (see the Milestone 4). More precisely:
  \begin{enumerate}
  \item In order to minimize the latency, the recorded chunks are sent
    to the interlocutor as soon as possible.
  \item The playback of the chunks extracted from the buffer is
    \href{https://en.wikipedia.org/wiki/Gapless_playback}{\emph{gapless}}
    (without the ocurrence of silences) as long as the chunks have
    been received on time.
  \item As always, the lost chunks are replaced by zero-chunks
    in the playback.
  \end{enumerate}
\item A method \verb|receive_and_buffer()| is run now in a different
  execution
  \href{https://en.wikipedia.org/wiki/Thread_(computing)}{thread},
  decoupled from the \verb|record_send_and_play()| method. But notice
  that using the sounddevice package this is achived without using the
  \href{https://docs.python.org/3/library/threading.html}{threading}
  nor
  \href{https://docs.python.org/3/library/multiprocessing.html}{multiprocessing}
  packages because the interruption handler (the so called
  \emph{callback}() function) already runs in parallel with the main
  thread.
\end{enumerate}

This is an overview of the implementation:

\begin{lstlisting}[language=Python]
  # Buffering InterCom
  def record_send_and_play():
    chunk = record()  # (1)
    packed_chunk = pack(chunk)  # (2)
    send(packed_chunk)  # (3)
    chunk = unbuffer_next_chunk()  # (4)
    play(chunk)  # (5)

  def receive_and_buffer():
    packed_chunk = receive()  # (1)
    chunk_number, chunk = unpack(packed_chunk)  # (2)
    buffer(chunk_number, chunk)  # (3)
\end{lstlisting}

Notice that the Step (4) of the method \verb|record_send_and_play()|
extractcs from the buffer an unpacked chunk. The chunks are buffered
in the Step (3) of the method \verb|receive_and_buffer()|.

%\begin{pseudocode}{Buffering\_InterCom}{~}
%  \PROCEDURE{record\_send\_and\_play}{~}
%  \BEGIN
%    \text{chunk} \GETS \text{record}()\\
%    \text{packed\_chunk} \GETS \text{pack}(\text{chunk})\\
%    \text{send}(\text{packed\_chunk})\\
%    \text{chunk} \GETS \text{unbuffer\_next\_chunk}()\\
%    \text{play}(\text{chunk})
%  \END
%  \ENDPROCEDURE
%  \PROCEDURE{receive\_and\_buffer}{~}
%  \BEGIN
%    \text{packed\_chunk} \GETS \text{receive}()\\
%    \text{chunk\_number}, \text{chunk} \GETS \text{unpack}(\text{packe%d\_chunk})\\
%    \text{buffer}(\text{chunk\_number}, \text{chunk})
%  \END
%  \ENDPROCEDURE
%\end{pseudocode}

\section{What do you have to do?}

Using the real scenario (two hosts in different LANs) used in the
previous milestone, or using a simulated scenario, execute
\verb|buffer.py| to inter-communicate two users (one user in the case
of the simulation). Use the \verb|--buffering_time| parameter to find
the minimum delay that provides a good QoE.

\section{Timming}

Please, finish this milestone in one week.

\section{Deliverables}

A report explaining your experiment and the corresponding results.

\section{Resources}

\bibliography{networking}
